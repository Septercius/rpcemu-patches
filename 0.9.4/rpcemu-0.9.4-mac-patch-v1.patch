--- original/ArmDynarec.c	2021-10-28 16:57:41.000000000 +0100
+++ src/ArmDynarec.c	2021-11-01 19:29:13.000000000 +0000
@@ -565,12 +565,39 @@
 {
 	const long page_size = sysconf(_SC_PAGESIZE);
 	const long page_mask = ~(page_size - 1);
-	void *start;
+	void *start, *addr;
 	long end;
+    int mmap_flags = 0;
 
 	start = (void *) ((long) ptr & page_mask);
 	end = ((long) ptr + len + page_size - 1) & page_mask;
 	len = (size_t) (end - (long) start);
+    
+#if __APPLE__
+    // More up-to-date versions of OS X require "mmap" to be called prior to "mprotect".
+    // Certain versions also require the MAP_JIT flag as well.
+    // Try without first, and if that fails, add the flag in.
+    mmap_flags = MAP_PRIVATE | MAP_ANON | MAP_FIXED;
+
+    addr = mmap(NULL, page_size, PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON, -1, 0);
+    if (addr == MAP_FAILED)
+    {
+        mmap_flags |= MAP_JIT;
+    }
+    else
+    {
+        munmap(addr, page_size);
+    }
+
+    addr = mmap(start, len, PROT_READ | PROT_WRITE | PROT_EXEC, mmap_flags, -1, 0);
+
+    if (addr == MAP_FAILED)
+    {
+        perror("mmap");
+        exit(1);
+    }
+
+#endif
 
 	if (mprotect(start, len, PROT_READ | PROT_WRITE | PROT_EXEC) != 0) {
 		perror("mprotect");
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/choose_dialog.cpp	2021-10-31 11:58:59.000000000 +0000
@@ -0,0 +1,107 @@
+/*
+ RPCEmu - An Acorn system emulator
+ 
+ Copyright (C) 2016-2017 Matthew Howkins
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <QFileDialog>
+#include "choose_dialog.h"
+#include "preferences-macosx.h"
+
+ChooseDialog::ChooseDialog(QWidget *parent) : QDialog(parent)
+{
+  setWindowTitle("RPCEmu - Choose Data Directory");
+  
+  buttons_box = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
+  
+  // Create preamble label.
+  QString str = QString("<p>Before using RPCEmu for the first time, you must select the directory <br/>"
+                        "that contains the folders and files required by the emulator, such as <br>"
+                        "ROMs, hard drive images and the HostFS share.</p>"
+                        "<p>You can show this dialogue again by holding down the Shift key <br/>"
+                        "whilst the application is loading.</p>");
+
+  preamble_label = new QLabel(str);
+  
+  // Create choose label.
+  choose_label = new QLabel();
+  choose_label->setText("Please choose a directory below:");
+  
+  // Create directory line edit.
+  directory_edit = new QLineEdit();
+  directory_edit->setMaxLength(511);
+  directory_edit->setReadOnly(true);
+  
+  // Create directory button.
+  directory_button = new QPushButton("Select...", this);
+  
+  // Create box for line edit and button.
+  directory_hbox = new QHBoxLayout();
+  directory_hbox->setSpacing(16);
+  directory_hbox->addWidget(directory_edit);
+  directory_hbox->addWidget(directory_button);
+  
+  grid = new QGridLayout(this);
+  grid->addWidget(preamble_label, 0, 0);
+  grid->addWidget(choose_label, 1, 0);
+  grid->addLayout(directory_hbox, 2, 0);
+  grid->addWidget(buttons_box, 3, 0);
+  
+  // Connect actions to widgets.
+  connect(directory_button, &QPushButton::pressed, this, &ChooseDialog::directory_button_pressed);
+  
+  connect(buttons_box, &QDialogButtonBox::accepted, this, &QDialog::accept);
+  connect(buttons_box, &QDialogButtonBox::rejected, this, &QDialog::reject);
+  
+  connect(this, &QDialog::accepted, this, &ChooseDialog::dialog_accepted);
+  connect(this, &QDialog::accepted, this, &ChooseDialog::dialog_rejected);
+
+  this->setFixedSize(this->sizeHint());
+}
+
+ChooseDialog::~ChooseDialog()
+{
+}
+
+void ChooseDialog::directory_button_pressed()
+{
+  QFileDialog folderDialog;
+  folderDialog.setWindowTitle("Choose Data Directory");
+  folderDialog.setFileMode(QFileDialog::Directory);
+  
+  if (folderDialog.exec())
+  {
+    QStringList selection = folderDialog.selectedFiles();
+    QString folderName = selection.at(0);
+    
+    directory_edit->setText(folderName);
+  }
+}
+
+void ChooseDialog::dialog_accepted()
+{
+  QString selectedFolder = directory_edit->text();
+  QByteArray ba = selectedFolder.toUtf8();
+  
+  char *ptr = ba.data();
+  preferences_set_data_directory(ptr);
+}
+
+void ChooseDialog::dialog_rejected()
+{
+}
+
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/choose_dialog.h	2021-10-31 11:58:59.000000000 +0000
@@ -0,0 +1,64 @@
+/*
+ RPCEmu - An Acorn system emulator
+ 
+ Copyright (C) 2016-2017 Matthew Howkins
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef CHOOSE_DIALOG_H
+#define CHOOSE_DIALOG_H
+
+#include <QDialog>
+#include <QDialogButtonBox>
+#include <QGridLayout>
+#include <QLabel>
+#include <QLineEdit>
+#include <QPushButton>
+
+#include "rpc-qt5.h"
+#include "rpcemu.h"
+
+class ChooseDialog : public QDialog
+{
+  
+  Q_OBJECT
+  
+public:
+  ChooseDialog(QWidget *parent = 0);
+  virtual ~ChooseDialog();
+  
+private slots:
+  void directory_button_pressed();
+  
+  void dialog_accepted();
+  void dialog_rejected();
+  
+private:
+  
+  QLabel *preamble_label;
+  QLabel *choose_label;
+  
+  QHBoxLayout *directory_hbox;
+  QLineEdit *directory_edit;
+  QPushButton *directory_button;
+  
+  QDialogButtonBox *buttons_box;
+  
+  QGridLayout *grid;
+  
+};
+
+#endif
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/macosx/events-macosx.h	2021-10-31 11:59:49.000000000 +0000
@@ -0,0 +1,45 @@
+/*
+ RPCEmu - An Acorn system emulator
+ 
+ Copyright (C) 2017 Peter Howkins
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __EVENTS_MACOSX_H__
+#define __EVENTS_MACOSX_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+    
+typedef enum {
+    nativeEventTypeModifiersChanged = 1
+} NativeEventType;
+    
+typedef struct
+{
+    bool processed;
+    int eventType;
+    uint modifierMask;
+} NativeEvent;
+    
+extern NativeEvent* handle_native_event(void *message);
+    
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __EVENTS_MACOSX_H__
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/macosx/events-macosx.m	2021-10-31 11:59:49.000000000 +0000
@@ -0,0 +1,56 @@
+/*
+ RPCEmu - An Acorn system emulator
+ 
+ Copyright (C) 2017 Matthew Howkins
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define UNUSED(x) (void)(x)
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <Cocoa/Cocoa.h>
+#include <Carbon/Carbon.h>
+#include <IOKit/hid/IOHIDLib.h>
+
+#include "rpcemu.h"
+
+#include "events-macosx.h"
+
+
+NativeEvent* handle_native_event(void *message)
+{
+    // This extracts information from the Cocoa event and passes it back up the chain to C++.
+    NSEvent *event = (NSEvent *) message;
+    
+    NativeEvent *result = (NativeEvent *) malloc(sizeof(NativeEvent));
+    
+    // Only handle flags changed events, which are raised for modifier key changes.
+    if (event.type == NSEventTypeFlagsChanged)
+    {
+        result->eventType = nativeEventTypeModifiersChanged;
+        result->modifierMask = event.modifierFlags;
+        result->processed = 1;
+    }
+    else
+    {
+        result->processed = 0;
+    }
+    
+    // Return zero if the event is not handled here.
+    return result;
+}
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/macosx/hid-macosx.h	2021-10-31 11:59:49.000000000 +0000
@@ -0,0 +1,34 @@
+///*
+// RPCEmu - An Acorn system emulator
+//
+// Copyright (C) 2017 Matthew Howkins
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+// */
+
+#ifndef __HID_MACOSX_H__
+#define __HID_MACOSX_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void init_hid_manager(void);
+    
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __HID_MACOSX_H__
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/macosx/hid-macosx.m	2021-10-31 11:59:49.000000000 +0000
@@ -0,0 +1,165 @@
+///*
+// RPCEmu - An Acorn system emulator
+//
+// Copyright (C) 2017 Matthew Howkins
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+// */
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <Cocoa/Cocoa.h>
+#include <Carbon/Carbon.h>
+#include <IOKit/hid/IOHIDLib.h>
+
+#include "keyboard.h"
+#include "keyboard_macosx.h"
+
+#define UNUSED(x) (void)(x)
+
+static IOHIDManagerRef hidManager = NULL;
+
+CFDictionaryRef createHIDDeviceMatchingDictionary(uint32 usagePage, uint32 usage)
+{
+    CFMutableDictionaryRef dictionary = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
+
+    if (dictionary)
+    {
+        CFNumberRef number = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &usagePage);
+        if (number)
+        {
+            CFDictionarySetValue(dictionary, CFSTR(kIOHIDDeviceUsagePageKey), number);
+            CFRelease(number);
+
+            number = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &usage);
+            if (number)
+            {
+                CFDictionarySetValue(dictionary, CFSTR(kIOHIDDeviceUsageKey), number);
+                CFRelease(number);
+
+                return dictionary;
+            }
+        }
+
+        CFRelease(dictionary);
+    }
+
+    return NULL;
+}
+
+void processHIDCallback(void *context, IOReturn result, void *sender, IOHIDValueRef value)
+{
+    UNUSED(result);
+    UNUSED(sender);
+
+    if (context != hidManager) return;
+
+    IOHIDElementRef element = IOHIDValueGetElement(value);
+    if (IOHIDElementGetUsagePage(element) != kHIDPage_KeyboardOrKeypad || IOHIDElementGetUsage(element) != kHIDUsage_KeyboardCapsLock) return;
+
+    CFIndex pressed = IOHIDValueGetIntegerValue(value);
+
+    uint8 scanCodes[] = { 0x58 };
+
+    if (pressed == 0)
+    {
+        keyboard_key_release(scanCodes);
+    }
+    else
+    {
+        keyboard_key_press(scanCodes);
+    }
+}
+
+const char *getCurrentKeyboardLayoutName()
+{
+    TISInputSourceRef currentSource = TISCopyCurrentKeyboardInputSource();
+    NSString *inputSource = (__bridge NSString *)(TISGetInputSourceProperty(currentSource, kTISPropertyInputSourceID));
+    NSUInteger lastIndex = [inputSource rangeOfString:@"." options:NSBackwardsSearch].location;
+    
+    NSString *layoutName = [inputSource substringFromIndex: lastIndex + 1];
+    lastIndex = [layoutName rangeOfString:@" - "].location;
+    
+    if (lastIndex != NSNotFound) layoutName = [layoutName substringToIndex: lastIndex];
+   
+    return [layoutName UTF8String];
+}
+
+void terminate_hid_manager(void)
+{
+    if (!hidManager) return;
+    
+    IOHIDManagerUnscheduleFromRunLoop(hidManager, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
+    IOHIDManagerRegisterInputValueCallback(hidManager, NULL, NULL);
+    IOHIDManagerClose(hidManager, 0);
+    
+    CFRelease(hidManager);
+    
+    hidManager = NULL;
+}
+
+void init_hid_manager(void)
+{
+    const char *layoutName = getCurrentKeyboardLayoutName();
+    keyboard_configure_layout(layoutName);
+
+    hidManager = IOHIDManagerCreate(kCFAllocatorDefault, kIOHIDOptionsTypeNone);
+    if (!hidManager) return;
+
+    CFDictionaryRef keyboard = NULL, keypad = NULL;
+    CFArrayRef matches = NULL;
+
+    keyboard = createHIDDeviceMatchingDictionary(kHIDPage_GenericDesktop, kHIDUsage_GD_Keyboard);
+    if (!keyboard)
+    {
+        IOHIDManagerClose(hidManager, 0);
+        return;
+    }
+
+    keypad = createHIDDeviceMatchingDictionary(kHIDPage_GenericDesktop, kHIDUsage_GD_Keypad);
+    if (!keypad)
+    {
+        CFRelease(keyboard);
+        IOHIDManagerClose(hidManager, 0);
+
+        return;
+    }
+
+    CFDictionaryRef matchesList[] = {keyboard, keypad};
+    matches = CFArrayCreate(kCFAllocatorDefault, (const void**) matchesList, 2, NULL);
+    if (!matches)
+    {
+        CFRelease(keypad);
+        CFRelease(keyboard);
+        IOHIDManagerClose(hidManager, 0);
+
+        return;
+    }
+
+    IOHIDManagerSetDeviceMatchingMultiple(hidManager, matches);
+    IOHIDManagerRegisterInputValueCallback(hidManager, processHIDCallback, hidManager);
+    IOHIDManagerScheduleWithRunLoop(hidManager, CFRunLoopGetMain(), kCFRunLoopDefaultMode);
+    if (IOHIDManagerOpen(hidManager, kIOHIDOptionsTypeNone) != kIOReturnSuccess)
+    {
+        terminate_hid_manager();
+    }
+
+    CFRelease(matches);
+    CFRelease(keypad);
+    CFRelease(keyboard);
+}
+
+
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/hostfs-macosx.c	2021-10-31 12:04:55.000000000 +0000
@@ -0,0 +1,121 @@
+#include <assert.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <utime.h>
+#include <sys/stat.h>
+
+#include "hostfs_internal.h"
+
+/**
+ * Convert ADFS time-stamped Load-Exec addresses to the equivalent time_t.
+ *
+ * @param load RISC OS load address (assumed to be time-stamped)
+ * @param exec RISC OS exec address (assumed to be time-stamped)
+ * @return Time converted to time_t format
+ *
+ * Code adapted from fs/adfs/inode.c from Linux licensed under GPL2.
+ * Copyright (C) 1997-1999 Russell King
+ */
+static time_t
+hostfs_adfs2host_time(uint32_t load, uint32_t exec)
+{
+	uint32_t high = load << 24;
+	uint32_t low  = exec;
+
+	high |= low >> 8;
+	low &= 0xff;
+
+	if (high < 0x3363996a) {
+		/* Too early */
+		return 0;
+	} else if (high >= 0x656e9969) {
+		/* Too late */
+		return 0x7ffffffd;
+	}
+
+	high -= 0x336e996a;
+	return (((high % 100) << 8) + low) / 100 + (high / 100 << 8);
+}
+
+/**
+ * Read information about an object.
+ *
+ * @param host_pathname Full Host path to object
+ * @param object_info   Return object info (filled-in)
+ */
+void
+hostfs_read_object_info_platform(const char *host_pathname,
+                                 risc_os_object_info *object_info)
+{
+	struct stat info;
+	uint32_t low, high;
+
+	assert(host_pathname != NULL);
+	assert(object_info != NULL);
+    
+  // Ignore DS_Store files.
+  if (strcasestr(host_pathname, ".DS_Store") != NULL)
+  {
+      object_info->type = OBJECT_TYPE_NOT_FOUND;
+      return;
+  }
+    
+	if (stat(host_pathname, &info)) {
+		/* Error reading info about the object */
+		switch (errno) {
+		case ENOENT: /* Object not found */
+		case ENOTDIR: /* A path component is not a directory */
+			object_info->type = OBJECT_TYPE_NOT_FOUND;
+			break;
+
+		default:
+			/* Other error */
+			fprintf(stderr,
+			        "hostfs_read_object_info_platform() could not stat() \'%s\': %s %d\n",
+			        host_pathname, strerror(errno), errno);
+			object_info->type = OBJECT_TYPE_NOT_FOUND;
+			break;
+		}
+
+		return;
+	}
+
+	/* We were able to read about the object */
+	if (S_ISREG(info.st_mode)) {
+		object_info->type = OBJECT_TYPE_FILE;
+	} else if (S_ISDIR(info.st_mode)) {
+		object_info->type = OBJECT_TYPE_DIRECTORY;
+	} else {
+		/* Treat types other than file or directory as not found */
+		object_info->type = OBJECT_TYPE_NOT_FOUND;
+		return;
+	}
+
+	low  = (uint32_t) ((info.st_mtime & 255) * 100);
+	high = (uint32_t) ((info.st_mtime / 256) * 100 + (low >> 8) + 0x336e996a);
+
+	/* If the file has filetype and timestamp, additional values will need to be filled in later */
+	object_info->load = (high >> 24);
+	object_info->exec = (low & 0xff) | (high << 8);
+
+	object_info->length = info.st_size;
+}
+
+/**
+ * Apply the timestamp to the supplied host object
+ *
+ * @param host_path Full path to object (file or dir) in host format
+ * @param load      RISC OS load address (must contain time-stamp)
+ * @param exec      RISC OS exec address (must contain time-stamp)
+ */
+void
+hostfs_object_set_timestamp_platform(const char *host_path, uint32_t load, uint32_t exec)
+{
+	struct utimbuf t;
+
+	t.actime = t.modtime = hostfs_adfs2host_time(load, exec);
+	utime(host_path, &t);
+	/* TODO handle error in utime() */
+}
--- original/hostfs.c	2021-10-28 16:57:41.000000000 +0100
+++ src/hostfs.c	2021-11-01 19:29:13.000000000 +0000
@@ -270,6 +270,9 @@
     case '<':
       *host_path++ = '$';
       break;
+    case (char) 160:
+      *host_path++ = ' ';
+      break;
     case '>':
       *host_path++ = '^';
       break;
@@ -539,7 +542,7 @@
   while ((entry = readdir(d)) != NULL) {
     char entry_path[PATH_MAX], ro_leaf[PATH_MAX];
 
-    /* Ignore the current directory and it's parent */
+    /* Ignore the current directory and its parent */
     if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
       continue;
     }
@@ -1650,7 +1653,7 @@
     char entry_path[PATH_MAX], ro_leaf[PATH_MAX];
     unsigned string_space;
 
-    /* Ignore the current directory and it's parent */
+    /* Ignore the current directory and its parent */
     if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
       continue;
     }
--- original/iomd.c	2021-10-28 16:57:41.000000000 +0100
+++ src/iomd.c	2021-11-01 19:29:13.000000000 +0000
@@ -840,19 +840,27 @@
 	}
 	/* Middle */
 	if (mouse_buttons & 4) {
+#ifdef __APPLE__
+        temp |= 0x20;
+#else
 		if (config.mousetwobutton) {
 			temp |= 0x10; // bit 4
 		} else {
 			temp |= 0x20; // bit 5
 		}
+#endif
 	}
 	/* Right */
 	if (mouse_buttons & 2) {
+#ifdef __APPLE__
+        temp |= 0x10;
+#else
 		if (config.mousetwobutton) {
 			temp |= 0x20; // bit 5
 		} else {
 			temp |= 0x10; // bit 4
 		}
+#endif
 	}
 
 	/* bit 0 contains the monitor id bit, 0 for VGA, 1 for TV type monitors.
--- original/keyboard.c	2021-10-28 16:57:41.000000000 +0100
+++ src/keyboard.c	2021-11-01 19:29:13.000000000 +0000
@@ -44,6 +44,10 @@
 #include "arm.h"
 #include "i8042.h"
 
+#ifdef __APPLE__
+#include "keyboard_macosx.h"
+#endif
+
 /* Keyboard Commands */
 #define KBD_CMD_ENABLE		0xf4
 #define KBD_CMD_RESET		0xff
@@ -257,6 +261,10 @@
 	/* Mousehack reset */
 	mouse_hack.pointer = 0;
 	mouse_hack.cursor_linked = 1;
+    
+#ifdef __APPLE__
+    keyboard_reset_modifiers(0);
+#endif
 }
 
 static uint8_t
@@ -734,6 +742,7 @@
 	{
 		uint8_t tmp;
 
+#ifndef __APPLE__
 		if (config.mousetwobutton) {
 			/* To help people with only two buttons on their mouse,
 			   swap the behaviour of middle and right buttons */
@@ -743,6 +752,7 @@
 
 			mouseb = mousel | (mousem << 1) | (mouser << 2);
 		}
+#endif
 
 		tmp = (mouseb & 7) | 8;
 
@@ -1195,6 +1205,17 @@
 	if (mouse.buttons & 1) { 
 		buttons |= 4;			/* Left button */
 	}
+    
+#ifdef __APPLE__
+    if (mouse.buttons & 2)
+    {
+        buttons |= 1;        /* Right button */
+    }
+    if (mouse.buttons & 4)
+    {
+        buttons |= 2;        /* Middle button */
+    }
+#else
 	if (config.mousetwobutton) {
 		/* To help people with only two buttons on their mouse, swap
 		   the behaviour of middle and right buttons */
@@ -1212,6 +1233,8 @@
 			buttons |= 2; 		/* Middle button */
 		}
 	}
+#endif
+    
 	arm.reg[2] = buttons;
 
 	arm.reg[3] = 0; /* R3 = time of button change */
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/keyboard_macosx.c	2021-10-31 12:05:13.000000000 +0000
@@ -0,0 +1,351 @@
+/*
+ RPCEmu - An Acorn system emulator
+ 
+ Copyright (C) 2017 Matthew Howkins
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include "rpcemu.h"
+#include "keyboard.h"
+
+#include <Carbon/Carbon.h>
+
+#define UNUSED(x) (void)(x)
+
+const int MAX_KEYBOARD_LAYOUTS = 20;
+
+typedef enum
+{
+    keyboardLayoutUndefined = 0,
+    keyboardLayoutBritish = 1,
+    keyboardLayoutFrench = 2
+} KeyboardLayoutType;
+
+static int keyboardType;
+
+typedef struct {
+    uint32_t    virtual_key[MAX_KEYBOARD_LAYOUTS];      // Cocoa virtual keys
+    uint8_t     set_2[8];                               // PS/2 Set 2 make code
+} KeyMapInfo;
+
+// Mac virtual keys can be found in the following file:
+//
+// /System/Library/Frameworks/Carbon.framework/Versions/A/Frameworks/HIToolbox.framework/Versions/A/Headers/Events.h.
+//
+// Key mappings are defined as follows:
+//
+// The first member is an array of virtual key codes.  There will be at least three elements in the array for each key.
+//
+// The first element indicates whether or not there are different mappings for different keyboard layouts for this key code.
+// If the value is 0, each keyboard layout uses the same mapping.  Where the value is 1, there are different mappings for different layouts.
+// An example of the former is "0" and of the latter, "Z" (in French, this is "Y").
+//
+// The second element in the array is the virtual key to use for the default language, British.
+// If additional, non-British languages are defined in the 'KeyboardLayoutType' enumeration (above) and in the
+// 'configureKeyboardLayout' function (below), virtual keys for these languages can be specified.
+// For example, on a French keyboard, 'Y' and 'Z' are transposed.  Therefore, for each of the mappings for these keys,
+// two virtual keys are listed.
+//
+// The list of virtual key codes must be terminated with an 0xFFFF element.
+//
+// The second member is an array of PS/2 set 2 codes.
+
+static const KeyMapInfo key_map[] = {
+    { { 0, kVK_Escape, 0xFFFF }, { 0x76 } },                       // Escape
+
+    { { 0, kVK_ISO_Section, 0xFFFF }, { 0x0e } },                  // `
+    { { 0, kVK_ANSI_1, 0xFFFF}, { 0x16 } },                        // 1
+    { { 0, kVK_ANSI_2, 0xFFFF }, { 0x1e } },                       // 2
+    { { 0, kVK_ANSI_3, 0xFFFF}, { 0x26 } },                        // 3
+    { { 0, kVK_ANSI_4, 0xFFFF }, { 0x25 } },                       // 4
+    { { 0, kVK_ANSI_5, 0xFFFF }, { 0x2e } },                       // 5
+    { { 0, kVK_ANSI_6, 0xFFFF }, { 0x36 } },                       // 6
+    { { 0, kVK_ANSI_7, 0xFFFF }, { 0x3d } },                       // 7
+    { { 0, kVK_ANSI_8, 0xFFFF }, { 0x3e } },                       // 8
+    { { 0, kVK_ANSI_9, 0xFFFF }, { 0x46 } },                       // 9
+    { { 0, kVK_ANSI_0, 0xFFFF }, { 0x45 } },                       // 0
+    { { 0, kVK_ANSI_Minus, 0xFFFF }, { 0x4e } },                   // -
+    { { 0, kVK_ANSI_Equal, 0xFFFF }, { 0x55 } },                   // =
+    { { 0, kVK_Delete, 0xFFFF }, { 0x66 } },                       // Backspace
+
+    { { 0, kVK_Tab, 0xFFFF }, { 0x0d } },                          // Tab
+    { { 0, kVK_ANSI_Q, 0xFFFF }, { 0x15 } },                       // Q
+    { { 0, kVK_ANSI_W, 0xFFFF }, { 0x1d } },                       // W
+    { { 0, kVK_ANSI_E, 0xFFFF }, { 0x24 } },                       // E
+    { { 0, kVK_ANSI_R, 0xFFFF }, { 0x2d } },                       // R
+    { { 0, kVK_ANSI_T, 0xFFFF}, { 0x2c } },                        // T
+    { { 1, kVK_ANSI_Y, kVK_ANSI_Z, 0xFFFF }, { 0x35 } },           // Y
+    { { 0, kVK_ANSI_U, 0xFFFF }, { 0x3c } },                       // U
+    { { 0, kVK_ANSI_I, 0xFFFF }, { 0x43 } },                       // I
+    { { 0, kVK_ANSI_O, 0xFFFF }, { 0x44 } },                       // O
+    { { 0, kVK_ANSI_P, 0xFFFF }, { 0x4d } },                       // P
+    { { 0, kVK_ANSI_LeftBracket, 0xFFFF }, { 0x54 } },             // [
+    { { 0, kVK_ANSI_RightBracket, 0xFFFF }, { 0x5b } },            // ]
+    { { 0, kVK_Return, 0xFFFF }, { 0x5a } },                       // Return
+
+    { { 0, kVK_Control, 0xFFFF }, { 0x14 } },                      // Left Ctrl
+    { { 0, kVK_ANSI_A, 0xFFFF }, { 0x1c } },                       // A
+    { { 0, kVK_ANSI_S, 0xFFFF }, { 0x1b } },                       // S
+    { { 0, kVK_ANSI_D, 0xFFFF }, { 0x23 } },                       // D
+    { { 0, kVK_ANSI_F, 0xFFFF }, { 0x2b } },                       // F
+    { { 0, kVK_ANSI_G, 0xFFFF }, { 0x34 } },                       // G
+    { { 1, kVK_ANSI_H, 0xFFFF }, { 0x33 } },                       // H
+    { { 0, kVK_ANSI_J, 0xFFFF }, { 0x3b } },                       // J
+    { { 0, kVK_ANSI_K, 0xFFFF }, { 0x42 } },                       // K
+    { { 0, kVK_ANSI_L, 0xFFFF }, { 0x4b } },                       // L
+    { { 0, kVK_ANSI_Semicolon, 0xFFFF }, { 0x4c } },               // ;
+    { { 0, kVK_ANSI_Quote, 0xFFFF }, { 0x52 } },                   // '
+    { { 0, kVK_ANSI_Backslash, 0xFFFF }, { 0x5d } },               // # (International only)
+
+    { { 0, kVK_ANSI_Grave, 0xFFFF }, { 0x61 } },                   // `
+    { { 1, kVK_ANSI_Z, kVK_ANSI_Y, 0xFFFF }, { 0x1a } },           // Z
+    { { 0, kVK_ANSI_X, 0xFFFF }, { 0x22 } },                       // X
+    { { 0, kVK_ANSI_C, 0xFFFF }, { 0x21 } },                       // C
+    { { 0, kVK_ANSI_V, 0xFFFF }, { 0x2a } },                       // V
+    { { 0, kVK_ANSI_B, 0xFFFF }, { 0x32 } },                       // B
+    { { 0, kVK_ANSI_N, 0xFFFF }, { 0x31 } },                       // N
+    { { 0, kVK_ANSI_M, 0xFFFF }, { 0x3a } },                       // M
+    { { 0, kVK_ANSI_Comma, 0xFFFF }, { 0x41 } },                   // ,
+    { { 0, kVK_ANSI_Period, 0xFFFF }, { 0x49 } },                  // .
+    { { 0, kVK_ANSI_Slash, 0xFFFF }, { 0x4a } },                   // /
+
+    { { 0, kVK_Space, 0xFFFF }, { 0x29 } },                        // Space
+
+    { { 0, kVK_F1, 0xFFFF }, { 0x05 } },                           // F1
+    { { 0, kVK_F2, 0xFFFF }, { 0x06 } },                           // F2
+    { { 0, kVK_F3, 0xFFFF }, { 0x04 } },                           // F3
+    { { 0, kVK_F4, 0xFFFF }, { 0x0c } },                           // F4
+    { { 0, kVK_F5, 0xFFFF }, { 0x03 } },                           // F5
+    { { 0, kVK_F6, 0xFFFF }, { 0x0b } },                           // F6
+    { { 0, kVK_F7, 0xFFFF }, { 0x83 } },                           // F7
+    { { 0, kVK_F8, 0xFFFF }, { 0x0a } },                           // F8
+    { { 0, kVK_F9, 0xFFFF }, { 0x01 } },                           // F9
+    { { 0, kVK_F10, 0xFFFF }, { 0x09 } },                          // F10
+    { { 0, kVK_F11, 0xFFFF }, { 0x78 } },                          // F11
+    { { 0, kVK_F12, 0xFFFF }, { 0x07 } },                          // F12
+
+    { { 0, kVK_F13, 0xFFFF }, { 0xe0, 0x7c } },                    // Print Screen/SysRq
+    { { 0, kVK_F14, 0xFFFF }, { 0x7e } },                          // Scroll Lock
+    { { 0, kVK_F15, 0xFFFF }, { 0xe1, 0x14, 0x77, 0xe1, 0xf0, 0x14, 0xf0, 0x77 } },    // Break
+
+    { { 0, kVK_ANSI_KeypadClear, 0xFFFF }, { 0x77 } },             // Keypad Num Lock
+    { { 0, kVK_ANSI_KeypadDivide, 0xFFFF }, { 0xe0, 0x4a } },      // Keypad /
+    { { 0, kVK_ANSI_KeypadMultiply, 0xFFFF }, { 0x7c } },          // Keypad *
+    { { 0, kVK_ANSI_Keypad7, 0xFFFF }, { 0x6c } },                 // Keypad 7
+    { { 0, kVK_ANSI_Keypad8, 0xFFFF }, { 0x75 } },                 // Keypad 8
+    { { 0, kVK_ANSI_Keypad9, 0xFFFF }, { 0x7d } },                 // Keypad 9
+    { { 0, kVK_ANSI_KeypadMinus, 0xFFFF }, { 0x7b } },             // Keypad -
+    { { 0, kVK_ANSI_Keypad4, 0xFFFF }, { 0x6b } },                 // Keypad 4
+    { { 0, kVK_ANSI_Keypad5, 0xFFFF }, { 0x73 } },                 // Keypad 5
+    { { 0, kVK_ANSI_Keypad6, 0xFFFF }, { 0x74 } },                 // Keypad 6
+    { { 0, kVK_ANSI_KeypadPlus, 0xFFFF }, { 0x79 } },              // Keypad +
+    { { 0, kVK_ANSI_Keypad1, 0xFFFF }, { 0x69 } },                 // Keypad 1
+    { { 0, kVK_ANSI_Keypad2, 0xFFFF }, { 0x72 } },                 // Keypad 2
+    { { 0, kVK_ANSI_Keypad3, 0xFFFF }, { 0x7a } },                 // Keypad 3
+    { { 0, kVK_ANSI_Keypad0, 0xFFFF }, { 0x70 } },                 // Keypad 0
+    { { 0, kVK_ANSI_KeypadDecimal, 0xFFFF }, { 0x71 } },           // Keypad .
+    { { 0, kVK_ANSI_KeypadEnter, 0xFFFF }, { 0xe0, 0x5a } },       // Keypad Enter
+
+    { { 0, kVK_Function, 0xFFFF }, { 0xe0, 0x70 } },               // Insert
+    { { 0, kVK_ForwardDelete, 0xFFFF }, { 0xe0, 0x71 } },          // Delete
+    { { 0, kVK_Home, 0xFFFF }, { 0xe0, 0x6c } },                   // Home
+    { { 0, kVK_End, 0xFFFF }, { 0xe0, 0x69 } },                    // End
+    { { 0, kVK_UpArrow, 0xFFFF }, { 0xe0, 0x75 } },                // Up
+    { { 0, kVK_DownArrow, 0xFFFF }, { 0xe0, 0x72 } },              // Down
+    { { 0, kVK_LeftArrow, 0xFFFF }, { 0xe0, 0x6b } },              // Left
+    { { 0, kVK_RightArrow, 0xFFFF }, { 0xe0, 0x74 } },             // Right
+    { { 0, kVK_PageUp, 0xFFFF }, { 0xe0, 0x7d } },                 // Page Up
+    { { 0, kVK_PageDown, 0xFFFF }, { 0xe0, 0x7a } },               // Page Down
+
+    { { 0, kVK_F16, 0xFFFF }, { 0xe0, 0x2f } },                    // Application (Win Menu)
+
+    { { 0xFFFF }, { 0, 0 } },
+};
+
+typedef enum
+{
+    modifierKeyStateShift = 0,
+    modifierKeyStateControl = 1,
+    modifierKeyStateAlt = 2,
+    modifierKeyStateCapsLock = 3,
+    modifierKeyStateCommand = 4
+} ModifierKeyCode;
+
+typedef struct
+{
+    int keyState[5];
+} ModifierState;
+
+ModifierState modifierState;
+
+typedef struct {
+    uint32_t modifierMask;
+    int checkMask;
+    uint maskLeft;
+    uint maskRight;
+    uint8_t set_2_left[8];
+    uint8_t set_2_right[8];
+    int simulateMenuButton;
+} ModifierMapInfo;
+
+// The following are from the "NSEventModifierFlagOption" enumeration.
+typedef enum
+{
+    nativeModifierFlagShift = (1 << 17),
+    nativeModifierFlagControl = (1<< 18),
+    nativeModifierFlagOption = (1 << 19),
+    nativeModifierFlagCommand = (1 << 20)
+} NativeModifierFlag;
+
+static const ModifierMapInfo modifier_map[] = {
+    {nativeModifierFlagShift, modifierKeyStateShift, 0x102, 0x104, {0x12}, {0x59}, 0 },                      // Shift.
+    {nativeModifierFlagControl, modifierKeyStateControl, 0x101, 0x2100, {0x14}, {0xe0, 0x14}, 0},            // Control.
+    {nativeModifierFlagOption, modifierKeyStateAlt, 0x120, 0x140, {0x11}, {0xe0, 0x11}, 0},                  // Alt.
+    {nativeModifierFlagCommand, modifierKeyStateCommand, 0x100108, 0x100110, {0xe0, 0x1f}, {0xe0, 0x27}, 1}, // Command.
+    {0x1<<31, 0, 0, 0, {0}, {0}, 0 },
+};
+
+int get_virtual_key_index(size_t k)
+{
+    if (key_map[k].virtual_key[0] == 0) return 1;
+    
+    for (int i = 1; i < MAX_KEYBOARD_LAYOUTS; i++)
+    {
+        if (key_map[k].virtual_key[i] == 0xFFFF) break;
+        if (i == keyboardType) return i;
+    }
+
+    return 0;
+}
+
+const uint8_t *
+keyboard_map_key(uint32_t native_scancode)
+{
+    size_t k;
+    int index;
+    
+    for (k = 0; key_map[k].virtual_key[0] != 0xFFFF; k++) {
+        index = get_virtual_key_index(k);
+
+        if (key_map[k].virtual_key[index] == native_scancode) {
+            return key_map[k].set_2;
+        }
+    }
+    return NULL;
+}
+
+void keyboard_handle_modifier_keys(uint mask)
+{
+    size_t k;
+    
+    for (k = 0; modifier_map[k].modifierMask != (1U << 31); k++)
+    {
+        int state = modifierState.keyState[modifier_map[k].checkMask];
+        uint modifierMask = modifier_map[k].modifierMask;
+      
+        if ((mask & modifierMask) != 0)
+        {
+            if (modifier_map[k].simulateMenuButton && config.mousetwobutton && state == 0)
+            {
+                state = 3;
+                mouse_mouse_press(4);
+            }
+            else
+            {
+                if ((mask & modifier_map[k].maskLeft) == modifier_map[k].maskLeft && (state & 1) == 0)
+                {
+                    state |= 1;
+                    keyboard_key_press(modifier_map[k].set_2_left);
+                }
+
+                if ((mask & modifier_map[k].maskRight) == modifier_map[k].maskRight && (state & 2) == 0)
+                {
+                    state |= 2;
+                    keyboard_key_press(modifier_map[k].set_2_right);
+                }
+            }
+        }
+        else if ((mask & modifierMask) == 0 && state != 0)
+        {
+            if (config.mousetwobutton && modifier_map[k].simulateMenuButton)
+            {
+                state = 0;
+                mouse_mouse_release(4);
+            }
+            else
+            {
+                if (state & 1)
+                {
+                    state &= ~1;
+                    keyboard_key_release(modifier_map[k].set_2_left);
+                }
+                if (state & 2)
+                {
+                    state &= ~2;
+                    keyboard_key_release(modifier_map[k].set_2_right);
+                }
+            }
+        }
+
+        modifierState.keyState[modifier_map[k].checkMask] = state;
+    }
+}
+
+void keyboard_reset_modifiers(int sendReleaseEvent)
+{
+    size_t k;
+
+    for (k = 0; modifier_map[k].modifierMask != (1U << 31); k++)
+    {
+        int state = modifierState.keyState[modifier_map[k].checkMask];
+        
+        if (sendReleaseEvent)
+        {
+            if (state & 1)
+            {
+                keyboard_key_release(modifier_map[k].set_2_left);
+            }
+            if (state & 2)
+            {
+                keyboard_key_release(modifier_map[k].set_2_right);
+            }
+        }
+        
+        modifierState.keyState[modifier_map[k].checkMask] = 0;
+    }
+}
+
+void keyboard_configure_layout(const char *layoutName)
+{
+    if (!strcmp(layoutName, "British")) keyboardType = keyboardLayoutBritish;
+    else if (!strcasecmp(layoutName, "French")) keyboardType = keyboardLayoutFrench;
+    else keyboardType = keyboardLayoutUndefined;
+    
+    if (keyboardType == keyboardLayoutUndefined)
+    {
+        fprintf(stderr, "Unsupported keyboard layout '%s' - reverting to 'British' (0).\n", layoutName);
+        keyboardType = keyboardLayoutBritish;
+    }
+    else
+    {
+        fprintf(stderr, "Using keyboard layout '%s' (%d).\n", layoutName, keyboardType);
+    }
+}
+
+int keyboard_check_special_keys()
+{
+    return (modifierState.keyState[modifierKeyStateControl] != 0 && modifierState.keyState[modifierKeyStateCommand] != 0);
+}
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/keyboard_macosx.h	2021-10-31 12:05:13.000000000 +0000
@@ -0,0 +1,40 @@
+/*
+ RPCEmu - An Acorn system emulator
+ 
+ Copyright (C) 2017 Matthew Howkins
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef __KEYBOARD_MACOSX_H__
+#define __KEYBOARD_MACOSX_H__
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+    
+extern void keyboard_handle_modifier_keys(uint32_t mask);
+extern void keyboard_reset_modifiers(int sendReleaseEvent);
+extern void keyboard_configure_layout(const char *layoutName);
+extern int keyboard_check_special_keys();
+    
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+        
+#endif
+
--- original/qt5/main_window.cpp	2021-10-31 13:26:13.000000000 +0000
+++ src/qt5/main_window.cpp	2021-11-01 19:29:13.000000000 +0000
@@ -31,7 +31,12 @@
 
 #if defined(Q_OS_WIN32)
 #include "Windows.h"
-#endif /* Q_OS_WIN32 */ 
+#endif /* Q_OS_WIN32 */
+
+#if defined(Q_OS_MACOS)
+#include "macosx/events-macosx.h"
+#include "keyboard_macosx.h"
+#endif /* Q_OS_MACOS */
 
 #include "rpcemu.h"
 #include "keyboard.h"
@@ -66,6 +71,9 @@
 void
 MainDisplay::mouseMoveEvent(QMouseEvent *event)
 {
+    // Ignore mouse events if the application is terminating.
+    if (quited) return;
+    
 	if((!pconfig_copy->mousehackon && mouse_captured) || full_screen) {
 		QPoint middle;
 
@@ -90,6 +98,9 @@
 void
 MainDisplay::mousePressEvent(QMouseEvent *event)
 {
+    // Ignore mouse events if the application is terminating.
+    if (quited) return;
+    
 	// Handle turning on mouse capture in capture mouse mode
 	if(!pconfig_copy->mousehackon) {
 		if(!mouse_captured) {
@@ -110,6 +121,9 @@
 void
 MainDisplay::mouseReleaseEvent(QMouseEvent *event)
 {
+    // Ignore mouse events if the application is terminating.
+    if (quited) return;
+    
 	if (event->button() & 7) {
 		emit this->emulator.mouse_release_signal(event->button() & 7);
 	}
@@ -366,7 +380,7 @@
 #ifdef RPCEMU_NETWORKING
 	network_dialog = new NetworkDialog(emulator, &config_copy, this);
 #endif /* RPCEMU_NETWORKING */
-//	nat_list_dialog = new NatListDialog(emulator, this);
+	nat_list_dialog = new NatListDialog(emulator, this);
 	about_dialog = new AboutDialog(this);
 
 	// MIPS counting
@@ -445,6 +459,10 @@
 
 	// Clear the list of keys considered to be held in the host
 	held_keys.clear();
+    
+#if defined(Q_OS_MACOS)
+    emit this->emulator.modifier_keys_reset_signal();
+#endif
 }
 
 /**
@@ -507,53 +525,18 @@
 	}
 
 	// Special case, check for Ctrl-End, our multi purpose do clever things key
-	if((Qt::Key_End == event->key()) && (event->modifiers() & Qt::ControlModifier)) {
-		if(full_screen) {
-			// Change Full Screen -> Windowed
-
-			display->set_full_screen(false);
-
-			int host_xsize, host_ysize;
-			display->get_host_size(host_xsize, host_ysize);
-			display->setFixedSize(host_xsize, host_ysize);
-
-			menuBar()->setVisible(true);
-			this->showNormal();
-			this->setFixedSize(this->sizeHint());
-
-			full_screen = false;
-
-			// Request redraw of display
-			display->update();
-			
-			// If we were in mousehack mode before entering fullscreen
-			// return to it now
-			if(reenable_mousehack) {
-				emit this->emulator.mouse_hack_signal();	
-			}
-			reenable_mousehack = false;
-			
-			// If we were in mouse capture mode before entering fullscreen
-			// and we hadn't captured the mouse, display the host cursor now
-			if(!config_copy.mousehackon && !mouse_captured) {
-				this->display->setCursor(Qt::ArrowCursor);
-			}
-			
-			return;
-		} else if(!pconfig_copy->mousehackon && mouse_captured) {
-			// Turn off mouse capture
-			mouse_captured = 0;
-
-			// show pointer in mouse capture mode when it's not been captured
-			this->display->setCursor(Qt::ArrowCursor);
-
-			return;
-		}
-	}
+	if((Qt::Key_End == event->key()) && (event->modifiers() & Qt::ControlModifier))
+	{
+        processMagicKeys();
+    }
 
 	// Regular case pass key press onto the emulator
 	if (!event->isAutoRepeat()) {
-		native_keypress_event(event->nativeScanCode());
+#if defined(Q_OS_MACOS)
+        native_keypress_event(event->nativeVirtualKey(), event->nativeModifiers());
+#else
+        native_keypress_event(event->nativeScanCode(), event->nativeModifiers());
+#endif
 	}
 }
 
@@ -573,7 +556,11 @@
 
 	// Regular case pass key release onto the emulator
 	if (!event->isAutoRepeat()) {
-		native_keyrelease_event(event->nativeScanCode());
+#if defined(Q_OS_MACOS)
+        native_keyrelease_event(event->nativeVirtualKey(), event->nativeModifiers());
+#else
+        native_keyrelease_event(event->nativeScanCode(), event->nativeModifiers());
+#endif    /* Q_OS_MACOS */
 	}
 }
 
@@ -583,8 +570,24 @@
  * @param scan_code Native scan code of key
  */
 void
-MainWindow::native_keypress_event(unsigned scan_code)
+MainWindow::native_keypress_event(unsigned scan_code, unsigned modifiers)
 {
+#if defined(Q_OS_MACOS)
+    if (!(scan_code == 0 && modifiers == 0))
+    {
+        // Check the key isn't already marked as held down (else ignore)
+        // (to deal with potentially inconsistent host messages)
+        bool found = (std::find(held_keys.begin(), held_keys.end(), scan_code) != held_keys.end());
+
+        if (!found) {
+            // Add the key to the list of held_keys, that will be released
+            // when the window loses the focus
+            held_keys.insert(held_keys.end(), scan_code);
+
+            emit this->emulator.key_press_signal(scan_code);
+        }
+    }
+#else
 	// Check the key isn't already marked as held down (else ignore)
 	// (to deal with potentially inconsistent host messages)
 	bool found = (std::find(held_keys.begin(), held_keys.end(), scan_code) != held_keys.end());
@@ -596,6 +599,7 @@
 
 		emit this->emulator.key_press_signal(scan_code);
 	}
+#endif
 }
 
 /**
@@ -604,8 +608,24 @@
  * @param scan_code Native scan code of key
  */
 void
-MainWindow::native_keyrelease_event(unsigned scan_code)
+MainWindow::native_keyrelease_event(unsigned scan_code, unsigned modifiers)
 {
+#if defined(Q_OS_MACOS)
+    if (!(scan_code == 0 && modifiers == 0))
+    {
+        // Check the key is marked as held down (else ignore)
+        // (to deal with potentially inconsistent host messages)
+        bool found = (std::find(held_keys.begin(), held_keys.end(), scan_code) != held_keys.end());
+
+        if (found) {
+            // Remove the key from the list of held_keys, that will be released
+            // when the window loses the focus
+            held_keys.remove(scan_code);
+
+            emit this->emulator.key_release_signal(scan_code);
+        }
+    }
+#else
 	// Check the key is marked as held down (else ignore)
 	// (to deal with potentially inconsistent host messages)
 	bool found = (std::find(held_keys.begin(), held_keys.end(), scan_code) != held_keys.end());
@@ -617,6 +637,7 @@
 
 		emit this->emulator.key_release_signal(scan_code);
 	}
+#endif
 }
 
 void
@@ -1309,7 +1330,7 @@
 void
 MainWindow::send_nat_rule_to_gui(PortForwardRule rule)
 {
-//	nat_list_dialog->add_nat_rule(rule);
+	nat_list_dialog->add_nat_rule(rule);
 }
 
 /**
@@ -1341,7 +1362,11 @@
 
 	if(!pconfig_copy->mousehackon) {
 		if(mouse_captured) {
+#if defined(Q_OS_MACOS)
+            capture_text = " Press CTRL-COMMAND to release mouse";
+#else
 			capture_text = " Press CTRL-END to release mouse";
+#endif
 		} else {
 			capture_text = " Click to capture mouse";
 		}
@@ -1443,6 +1468,52 @@
 #endif
 	}
 }
+    
+void
+MainWindow::processMagicKeys()
+{
+    if(full_screen) {
+        // Change Full Screen -> Windowed
+
+        display->set_full_screen(false);
+
+        int host_xsize, host_ysize;
+        display->get_host_size(host_xsize, host_ysize);
+        display->setFixedSize(host_xsize, host_ysize);
+
+        menuBar()->setVisible(true);
+        this->showNormal();
+        this->setFixedSize(this->sizeHint());
+
+        full_screen = false;
+
+        // Request redraw of display
+        display->update();
+
+        // If we were in mousehack mode before entering fullscreen
+        // return to it now
+        if(reenable_mousehack) {
+            emit this->emulator.mouse_hack_signal();
+        }
+        reenable_mousehack = false;
+
+        // If we were in mouse capture mode before entering fullscreen
+        // and we hadn't captured the mouse, display the host cursor now
+        if(!config_copy.mousehackon && !mouse_captured) {
+            this->display->setCursor(Qt::ArrowCursor);
+        }
+
+        return;
+    } else if(!pconfig_copy->mousehackon && mouse_captured) {
+        // Turn off mouse capture
+        mouse_captured = 0;
+
+        // show pointer in mouse capture mode when it's not been captured
+        this->display->setCursor(Qt::ArrowCursor);
+
+        return;
+    }
+}
 
 #if defined(Q_OS_WIN32)
 /**
@@ -1502,3 +1573,46 @@
 	return false;
 }
 #endif // Q_OS_WIN32
+
+#if defined(Q_OS_MACOS)
+/**
+ * On OS X, handle additional events for modifier keys.  The normal key press/release
+ * events do not differentiate between left and right.
+ *
+ * @param eventType unused
+ * @param message window event NSEvent data
+ * @param result unused
+ * @return bool of whether we've handled the event (true) or OS X/QT should deal with it (false)
+ */
+bool
+MainWindow::nativeEvent(const QByteArray &eventType, void *message, long *result)
+{
+    Q_UNUSED(eventType);
+    Q_UNUSED(result);
+
+    NativeEvent *event = handle_native_event(message);
+    if (!event->processed)
+    {
+        free(event);
+        return false;
+    }
+
+    if (event->eventType == nativeEventTypeModifiersChanged)
+    {
+        // Modifier key state has changed.
+        emit this->emulator.modifier_keys_changed_signal(event->modifierMask);
+
+        if (keyboard_check_special_keys())
+        {
+            // Magic key combination to release mouse capture.
+            processMagicKeys();
+        }
+
+        free(event);
+    }
+
+    return true;
+}
+
+#endif /* Q_OS_MACOS */
+    
--- original/qt5/main_window.h	2021-10-28 16:57:41.000000000 +0100
+++ src/qt5/main_window.h	2021-11-01 19:29:13.000000000 +0000
@@ -110,7 +110,7 @@
 	void closeEvent(QCloseEvent *event) Q_DECL_OVERRIDE;
 	void keyPressEvent(QKeyEvent *event) Q_DECL_OVERRIDE;
 	void keyReleaseEvent(QKeyEvent *event) Q_DECL_OVERRIDE;
-#if defined(Q_OS_WIN32)
+#if defined(Q_OS_WIN32) || defined(Q_OS_MACOS)
 	bool nativeEvent(const QByteArray &eventType, void *message, long *result) Q_DECL_OVERRIDE;
 #endif /* Q_OS_WIN32 */
 	
@@ -169,9 +169,11 @@
 
 	void cdrom_menu_selection_update(const QAction *cdrom_action);
 
-	void native_keypress_event(unsigned scan_code);
-	void native_keyrelease_event(unsigned scan_code);
+	void native_keypress_event(unsigned scan_code, unsigned modifiers);
+	void native_keyrelease_event(unsigned scan_code, unsigned modifiers);
 	void release_held_keys();
+    
+    void processMagicKeys();
 
 	bool full_screen;
 	bool reenable_mousehack; ///< Did we disable mousehack entering fullscreen and have to reenable it on leaving fullscreen?
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/moc_about_dialog.cpp	2021-10-31 18:46:59.000000000 +0000
@@ -0,0 +1,94 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'about_dialog.h'
+**
+** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.11)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "about_dialog.h"
+#include <QtCore/qbytearray.h>
+#include <QtCore/qmetatype.h>
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'about_dialog.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 67
+#error "This file was generated using the moc from 5.12.11. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
+struct qt_meta_stringdata_AboutDialog_t {
+    QByteArrayData data[1];
+    char stringdata0[12];
+};
+#define QT_MOC_LITERAL(idx, ofs, len) \
+    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
+    qptrdiff(offsetof(qt_meta_stringdata_AboutDialog_t, stringdata0) + ofs \
+        - idx * sizeof(QByteArrayData)) \
+    )
+static const qt_meta_stringdata_AboutDialog_t qt_meta_stringdata_AboutDialog = {
+    {
+QT_MOC_LITERAL(0, 0, 11) // "AboutDialog"
+
+    },
+    "AboutDialog"
+};
+#undef QT_MOC_LITERAL
+
+static const uint qt_meta_data_AboutDialog[] = {
+
+ // content:
+       8,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       0,    0, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+       0        // eod
+};
+
+void AboutDialog::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    Q_UNUSED(_o);
+    Q_UNUSED(_id);
+    Q_UNUSED(_c);
+    Q_UNUSED(_a);
+}
+
+QT_INIT_METAOBJECT const QMetaObject AboutDialog::staticMetaObject = { {
+    &QDialog::staticMetaObject,
+    qt_meta_stringdata_AboutDialog.data,
+    qt_meta_data_AboutDialog,
+    qt_static_metacall,
+    nullptr,
+    nullptr
+} };
+
+
+const QMetaObject *AboutDialog::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
+}
+
+void *AboutDialog::qt_metacast(const char *_clname)
+{
+    if (!_clname) return nullptr;
+    if (!strcmp(_clname, qt_meta_stringdata_AboutDialog.stringdata0))
+        return static_cast<void*>(this);
+    return QDialog::qt_metacast(_clname);
+}
+
+int AboutDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QDialog::qt_metacall(_c, _id, _a);
+    return _id;
+}
+QT_WARNING_POP
+QT_END_MOC_NAMESPACE
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/moc_choose_dialog.cpp	2021-10-31 18:47:01.000000000 +0000
@@ -0,0 +1,127 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'choose_dialog.h'
+**
+** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.11)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "choose_dialog.h"
+#include <QtCore/qbytearray.h>
+#include <QtCore/qmetatype.h>
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'choose_dialog.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 67
+#error "This file was generated using the moc from 5.12.11. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
+struct qt_meta_stringdata_ChooseDialog_t {
+    QByteArrayData data[5];
+    char stringdata0[71];
+};
+#define QT_MOC_LITERAL(idx, ofs, len) \
+    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
+    qptrdiff(offsetof(qt_meta_stringdata_ChooseDialog_t, stringdata0) + ofs \
+        - idx * sizeof(QByteArrayData)) \
+    )
+static const qt_meta_stringdata_ChooseDialog_t qt_meta_stringdata_ChooseDialog = {
+    {
+QT_MOC_LITERAL(0, 0, 12), // "ChooseDialog"
+QT_MOC_LITERAL(1, 13, 24), // "directory_button_pressed"
+QT_MOC_LITERAL(2, 38, 0), // ""
+QT_MOC_LITERAL(3, 39, 15), // "dialog_accepted"
+QT_MOC_LITERAL(4, 55, 15) // "dialog_rejected"
+
+    },
+    "ChooseDialog\0directory_button_pressed\0"
+    "\0dialog_accepted\0dialog_rejected"
+};
+#undef QT_MOC_LITERAL
+
+static const uint qt_meta_data_ChooseDialog[] = {
+
+ // content:
+       8,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       3,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: name, argc, parameters, tag, flags
+       1,    0,   29,    2, 0x08 /* Private */,
+       3,    0,   30,    2, 0x08 /* Private */,
+       4,    0,   31,    2, 0x08 /* Private */,
+
+ // slots: parameters
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+
+       0        // eod
+};
+
+void ChooseDialog::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        auto *_t = static_cast<ChooseDialog *>(_o);
+        Q_UNUSED(_t)
+        switch (_id) {
+        case 0: _t->directory_button_pressed(); break;
+        case 1: _t->dialog_accepted(); break;
+        case 2: _t->dialog_rejected(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+QT_INIT_METAOBJECT const QMetaObject ChooseDialog::staticMetaObject = { {
+    &QDialog::staticMetaObject,
+    qt_meta_stringdata_ChooseDialog.data,
+    qt_meta_data_ChooseDialog,
+    qt_static_metacall,
+    nullptr,
+    nullptr
+} };
+
+
+const QMetaObject *ChooseDialog::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
+}
+
+void *ChooseDialog::qt_metacast(const char *_clname)
+{
+    if (!_clname) return nullptr;
+    if (!strcmp(_clname, qt_meta_stringdata_ChooseDialog.stringdata0))
+        return static_cast<void*>(this);
+    return QDialog::qt_metacast(_clname);
+}
+
+int ChooseDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QDialog::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 3)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 3;
+    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
+        if (_id < 3)
+            *reinterpret_cast<int*>(_a[0]) = -1;
+        _id -= 3;
+    }
+    return _id;
+}
+QT_WARNING_POP
+QT_END_MOC_NAMESPACE
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/moc_configure_dialog.cpp	2021-10-31 18:46:59.000000000 +0000
@@ -0,0 +1,127 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'configure_dialog.h'
+**
+** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.11)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "configure_dialog.h"
+#include <QtCore/qbytearray.h>
+#include <QtCore/qmetatype.h>
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'configure_dialog.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 67
+#error "This file was generated using the moc from 5.12.11. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
+struct qt_meta_stringdata_ConfigureDialog_t {
+    QByteArrayData data[6];
+    char stringdata0[68];
+};
+#define QT_MOC_LITERAL(idx, ofs, len) \
+    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
+    qptrdiff(offsetof(qt_meta_stringdata_ConfigureDialog_t, stringdata0) + ofs \
+        - idx * sizeof(QByteArrayData)) \
+    )
+static const qt_meta_stringdata_ConfigureDialog_t qt_meta_stringdata_ConfigureDialog = {
+    {
+QT_MOC_LITERAL(0, 0, 15), // "ConfigureDialog"
+QT_MOC_LITERAL(1, 16, 12), // "slider_moved"
+QT_MOC_LITERAL(2, 29, 0), // ""
+QT_MOC_LITERAL(3, 30, 5), // "value"
+QT_MOC_LITERAL(4, 36, 15), // "dialog_accepted"
+QT_MOC_LITERAL(5, 52, 15) // "dialog_rejected"
+
+    },
+    "ConfigureDialog\0slider_moved\0\0value\0"
+    "dialog_accepted\0dialog_rejected"
+};
+#undef QT_MOC_LITERAL
+
+static const uint qt_meta_data_ConfigureDialog[] = {
+
+ // content:
+       8,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       3,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: name, argc, parameters, tag, flags
+       1,    1,   29,    2, 0x08 /* Private */,
+       4,    0,   32,    2, 0x08 /* Private */,
+       5,    0,   33,    2, 0x08 /* Private */,
+
+ // slots: parameters
+    QMetaType::Void, QMetaType::Int,    3,
+    QMetaType::Void,
+    QMetaType::Void,
+
+       0        // eod
+};
+
+void ConfigureDialog::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        auto *_t = static_cast<ConfigureDialog *>(_o);
+        Q_UNUSED(_t)
+        switch (_id) {
+        case 0: _t->slider_moved((*reinterpret_cast< int(*)>(_a[1]))); break;
+        case 1: _t->dialog_accepted(); break;
+        case 2: _t->dialog_rejected(); break;
+        default: ;
+        }
+    }
+}
+
+QT_INIT_METAOBJECT const QMetaObject ConfigureDialog::staticMetaObject = { {
+    &QDialog::staticMetaObject,
+    qt_meta_stringdata_ConfigureDialog.data,
+    qt_meta_data_ConfigureDialog,
+    qt_static_metacall,
+    nullptr,
+    nullptr
+} };
+
+
+const QMetaObject *ConfigureDialog::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
+}
+
+void *ConfigureDialog::qt_metacast(const char *_clname)
+{
+    if (!_clname) return nullptr;
+    if (!strcmp(_clname, qt_meta_stringdata_ConfigureDialog.stringdata0))
+        return static_cast<void*>(this);
+    return QDialog::qt_metacast(_clname);
+}
+
+int ConfigureDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QDialog::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 3)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 3;
+    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
+        if (_id < 3)
+            *reinterpret_cast<int*>(_a[0]) = -1;
+        _id -= 3;
+    }
+    return _id;
+}
+QT_WARNING_POP
+QT_END_MOC_NAMESPACE
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/moc_main_window.cpp	2021-10-31 18:46:59.000000000 +0000
@@ -0,0 +1,410 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'main_window.h'
+**
+** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.11)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "main_window.h"
+#include <QtCore/qbytearray.h>
+#include <QtCore/qmetatype.h>
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'main_window.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 67
+#error "This file was generated using the moc from 5.12.11. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
+struct qt_meta_stringdata_MainDisplay_t {
+    QByteArrayData data[1];
+    char stringdata0[12];
+};
+#define QT_MOC_LITERAL(idx, ofs, len) \
+    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
+    qptrdiff(offsetof(qt_meta_stringdata_MainDisplay_t, stringdata0) + ofs \
+        - idx * sizeof(QByteArrayData)) \
+    )
+static const qt_meta_stringdata_MainDisplay_t qt_meta_stringdata_MainDisplay = {
+    {
+QT_MOC_LITERAL(0, 0, 11) // "MainDisplay"
+
+    },
+    "MainDisplay"
+};
+#undef QT_MOC_LITERAL
+
+static const uint qt_meta_data_MainDisplay[] = {
+
+ // content:
+       8,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       0,    0, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+       0        // eod
+};
+
+void MainDisplay::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    Q_UNUSED(_o);
+    Q_UNUSED(_id);
+    Q_UNUSED(_c);
+    Q_UNUSED(_a);
+}
+
+QT_INIT_METAOBJECT const QMetaObject MainDisplay::staticMetaObject = { {
+    &QWidget::staticMetaObject,
+    qt_meta_stringdata_MainDisplay.data,
+    qt_meta_data_MainDisplay,
+    qt_static_metacall,
+    nullptr,
+    nullptr
+} };
+
+
+const QMetaObject *MainDisplay::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
+}
+
+void *MainDisplay::qt_metacast(const char *_clname)
+{
+    if (!_clname) return nullptr;
+    if (!strcmp(_clname, qt_meta_stringdata_MainDisplay.stringdata0))
+        return static_cast<void*>(this);
+    return QWidget::qt_metacast(_clname);
+}
+
+int MainDisplay::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QWidget::qt_metacall(_c, _id, _a);
+    return _id;
+}
+struct qt_meta_stringdata_MainWindow_t {
+    QByteArrayData data[42];
+    char stringdata0[661];
+};
+#define QT_MOC_LITERAL(idx, ofs, len) \
+    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
+    qptrdiff(offsetof(qt_meta_stringdata_MainWindow_t, stringdata0) + ofs \
+        - idx * sizeof(QByteArrayData)) \
+    )
+static const qt_meta_stringdata_MainWindow_t qt_meta_stringdata_MainWindow = {
+    {
+QT_MOC_LITERAL(0, 0, 10), // "MainWindow"
+QT_MOC_LITERAL(1, 11, 19), // "main_display_signal"
+QT_MOC_LITERAL(2, 31, 0), // ""
+QT_MOC_LITERAL(3, 32, 11), // "VideoUpdate"
+QT_MOC_LITERAL(4, 44, 12), // "video_update"
+QT_MOC_LITERAL(5, 57, 22), // "move_host_mouse_signal"
+QT_MOC_LITERAL(6, 80, 15), // "MouseMoveUpdate"
+QT_MOC_LITERAL(7, 96, 12), // "mouse_update"
+QT_MOC_LITERAL(8, 109, 27), // "send_nat_rule_to_gui_signal"
+QT_MOC_LITERAL(9, 137, 15), // "PortForwardRule"
+QT_MOC_LITERAL(10, 153, 4), // "rule"
+QT_MOC_LITERAL(11, 158, 12), // "error_signal"
+QT_MOC_LITERAL(12, 171, 5), // "error"
+QT_MOC_LITERAL(13, 177, 12), // "fatal_signal"
+QT_MOC_LITERAL(14, 190, 15), // "menu_screenshot"
+QT_MOC_LITERAL(15, 206, 10), // "menu_reset"
+QT_MOC_LITERAL(16, 217, 14), // "menu_loaddisc0"
+QT_MOC_LITERAL(17, 232, 14), // "menu_loaddisc1"
+QT_MOC_LITERAL(18, 247, 19), // "menu_cdrom_disabled"
+QT_MOC_LITERAL(19, 267, 16), // "menu_cdrom_empty"
+QT_MOC_LITERAL(20, 284, 14), // "menu_cdrom_iso"
+QT_MOC_LITERAL(21, 299, 16), // "menu_cdrom_ioctl"
+QT_MOC_LITERAL(22, 316, 20), // "menu_cdrom_win_ioctl"
+QT_MOC_LITERAL(23, 337, 14), // "menu_configure"
+QT_MOC_LITERAL(24, 352, 15), // "menu_networking"
+QT_MOC_LITERAL(25, 368, 13), // "menu_nat_list"
+QT_MOC_LITERAL(26, 382, 15), // "menu_fullscreen"
+QT_MOC_LITERAL(27, 398, 13), // "menu_cpu_idle"
+QT_MOC_LITERAL(28, 412, 15), // "menu_mouse_hack"
+QT_MOC_LITERAL(29, 428, 20), // "menu_mouse_twobutton"
+QT_MOC_LITERAL(30, 449, 18), // "menu_online_manual"
+QT_MOC_LITERAL(31, 468, 18), // "menu_visit_website"
+QT_MOC_LITERAL(32, 487, 10), // "menu_about"
+QT_MOC_LITERAL(33, 498, 16), // "menu_aboutToShow"
+QT_MOC_LITERAL(34, 515, 16), // "menu_aboutToHide"
+QT_MOC_LITERAL(35, 532, 19), // "main_display_update"
+QT_MOC_LITERAL(36, 552, 15), // "move_host_mouse"
+QT_MOC_LITERAL(37, 568, 20), // "send_nat_rule_to_gui"
+QT_MOC_LITERAL(38, 589, 18), // "mips_timer_timeout"
+QT_MOC_LITERAL(39, 608, 25), // "application_state_changed"
+QT_MOC_LITERAL(40, 634, 20), // "Qt::ApplicationState"
+QT_MOC_LITERAL(41, 655, 5) // "state"
+
+    },
+    "MainWindow\0main_display_signal\0\0"
+    "VideoUpdate\0video_update\0"
+    "move_host_mouse_signal\0MouseMoveUpdate\0"
+    "mouse_update\0send_nat_rule_to_gui_signal\0"
+    "PortForwardRule\0rule\0error_signal\0"
+    "error\0fatal_signal\0menu_screenshot\0"
+    "menu_reset\0menu_loaddisc0\0menu_loaddisc1\0"
+    "menu_cdrom_disabled\0menu_cdrom_empty\0"
+    "menu_cdrom_iso\0menu_cdrom_ioctl\0"
+    "menu_cdrom_win_ioctl\0menu_configure\0"
+    "menu_networking\0menu_nat_list\0"
+    "menu_fullscreen\0menu_cpu_idle\0"
+    "menu_mouse_hack\0menu_mouse_twobutton\0"
+    "menu_online_manual\0menu_visit_website\0"
+    "menu_about\0menu_aboutToShow\0"
+    "menu_aboutToHide\0main_display_update\0"
+    "move_host_mouse\0send_nat_rule_to_gui\0"
+    "mips_timer_timeout\0application_state_changed\0"
+    "Qt::ApplicationState\0state"
+};
+#undef QT_MOC_LITERAL
+
+static const uint qt_meta_data_MainWindow[] = {
+
+ // content:
+       8,       // revision
+       0,       // classname
+       0,    0, // classinfo
+      31,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       5,       // signalCount
+
+ // signals: name, argc, parameters, tag, flags
+       1,    1,  169,    2, 0x06 /* Public */,
+       5,    1,  172,    2, 0x06 /* Public */,
+       8,    1,  175,    2, 0x06 /* Public */,
+      11,    1,  178,    2, 0x06 /* Public */,
+      13,    1,  181,    2, 0x06 /* Public */,
+
+ // slots: name, argc, parameters, tag, flags
+      14,    0,  184,    2, 0x08 /* Private */,
+      15,    0,  185,    2, 0x08 /* Private */,
+      16,    0,  186,    2, 0x08 /* Private */,
+      17,    0,  187,    2, 0x08 /* Private */,
+      18,    0,  188,    2, 0x08 /* Private */,
+      19,    0,  189,    2, 0x08 /* Private */,
+      20,    0,  190,    2, 0x08 /* Private */,
+      21,    0,  191,    2, 0x08 /* Private */,
+      22,    0,  192,    2, 0x08 /* Private */,
+      23,    0,  193,    2, 0x08 /* Private */,
+      24,    0,  194,    2, 0x08 /* Private */,
+      25,    0,  195,    2, 0x08 /* Private */,
+      26,    0,  196,    2, 0x08 /* Private */,
+      27,    0,  197,    2, 0x08 /* Private */,
+      28,    0,  198,    2, 0x08 /* Private */,
+      29,    0,  199,    2, 0x08 /* Private */,
+      30,    0,  200,    2, 0x08 /* Private */,
+      31,    0,  201,    2, 0x08 /* Private */,
+      32,    0,  202,    2, 0x08 /* Private */,
+      33,    0,  203,    2, 0x08 /* Private */,
+      34,    0,  204,    2, 0x08 /* Private */,
+      35,    1,  205,    2, 0x08 /* Private */,
+      36,    1,  208,    2, 0x08 /* Private */,
+      37,    1,  211,    2, 0x08 /* Private */,
+      38,    0,  214,    2, 0x08 /* Private */,
+      39,    1,  215,    2, 0x08 /* Private */,
+
+ // signals: parameters
+    QMetaType::Void, 0x80000000 | 3,    4,
+    QMetaType::Void, 0x80000000 | 6,    7,
+    QMetaType::Void, 0x80000000 | 9,   10,
+    QMetaType::Void, QMetaType::QString,   12,
+    QMetaType::Void, QMetaType::QString,   12,
+
+ // slots: parameters
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void, 0x80000000 | 3,    4,
+    QMetaType::Void, 0x80000000 | 6,    7,
+    QMetaType::Void, 0x80000000 | 9,   10,
+    QMetaType::Void,
+    QMetaType::Void, 0x80000000 | 40,   41,
+
+       0        // eod
+};
+
+void MainWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        auto *_t = static_cast<MainWindow *>(_o);
+        Q_UNUSED(_t)
+        switch (_id) {
+        case 0: _t->main_display_signal((*reinterpret_cast< VideoUpdate(*)>(_a[1]))); break;
+        case 1: _t->move_host_mouse_signal((*reinterpret_cast< MouseMoveUpdate(*)>(_a[1]))); break;
+        case 2: _t->send_nat_rule_to_gui_signal((*reinterpret_cast< PortForwardRule(*)>(_a[1]))); break;
+        case 3: _t->error_signal((*reinterpret_cast< QString(*)>(_a[1]))); break;
+        case 4: _t->fatal_signal((*reinterpret_cast< QString(*)>(_a[1]))); break;
+        case 5: _t->menu_screenshot(); break;
+        case 6: _t->menu_reset(); break;
+        case 7: _t->menu_loaddisc0(); break;
+        case 8: _t->menu_loaddisc1(); break;
+        case 9: _t->menu_cdrom_disabled(); break;
+        case 10: _t->menu_cdrom_empty(); break;
+        case 11: _t->menu_cdrom_iso(); break;
+        case 12: _t->menu_cdrom_ioctl(); break;
+        case 13: _t->menu_cdrom_win_ioctl(); break;
+        case 14: _t->menu_configure(); break;
+        case 15: _t->menu_networking(); break;
+        case 16: _t->menu_nat_list(); break;
+        case 17: _t->menu_fullscreen(); break;
+        case 18: _t->menu_cpu_idle(); break;
+        case 19: _t->menu_mouse_hack(); break;
+        case 20: _t->menu_mouse_twobutton(); break;
+        case 21: _t->menu_online_manual(); break;
+        case 22: _t->menu_visit_website(); break;
+        case 23: _t->menu_about(); break;
+        case 24: _t->menu_aboutToShow(); break;
+        case 25: _t->menu_aboutToHide(); break;
+        case 26: _t->main_display_update((*reinterpret_cast< VideoUpdate(*)>(_a[1]))); break;
+        case 27: _t->move_host_mouse((*reinterpret_cast< MouseMoveUpdate(*)>(_a[1]))); break;
+        case 28: _t->send_nat_rule_to_gui((*reinterpret_cast< PortForwardRule(*)>(_a[1]))); break;
+        case 29: _t->mips_timer_timeout(); break;
+        case 30: _t->application_state_changed((*reinterpret_cast< Qt::ApplicationState(*)>(_a[1]))); break;
+        default: ;
+        }
+    } else if (_c == QMetaObject::IndexOfMethod) {
+        int *result = reinterpret_cast<int *>(_a[0]);
+        {
+            using _t = void (MainWindow::*)(VideoUpdate );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&MainWindow::main_display_signal)) {
+                *result = 0;
+                return;
+            }
+        }
+        {
+            using _t = void (MainWindow::*)(MouseMoveUpdate );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&MainWindow::move_host_mouse_signal)) {
+                *result = 1;
+                return;
+            }
+        }
+        {
+            using _t = void (MainWindow::*)(PortForwardRule );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&MainWindow::send_nat_rule_to_gui_signal)) {
+                *result = 2;
+                return;
+            }
+        }
+        {
+            using _t = void (MainWindow::*)(QString );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&MainWindow::error_signal)) {
+                *result = 3;
+                return;
+            }
+        }
+        {
+            using _t = void (MainWindow::*)(QString );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&MainWindow::fatal_signal)) {
+                *result = 4;
+                return;
+            }
+        }
+    }
+}
+
+QT_INIT_METAOBJECT const QMetaObject MainWindow::staticMetaObject = { {
+    &QMainWindow::staticMetaObject,
+    qt_meta_stringdata_MainWindow.data,
+    qt_meta_data_MainWindow,
+    qt_static_metacall,
+    nullptr,
+    nullptr
+} };
+
+
+const QMetaObject *MainWindow::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
+}
+
+void *MainWindow::qt_metacast(const char *_clname)
+{
+    if (!_clname) return nullptr;
+    if (!strcmp(_clname, qt_meta_stringdata_MainWindow.stringdata0))
+        return static_cast<void*>(this);
+    return QMainWindow::qt_metacast(_clname);
+}
+
+int MainWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QMainWindow::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 31)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 31;
+    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
+        if (_id < 31)
+            *reinterpret_cast<int*>(_a[0]) = -1;
+        _id -= 31;
+    }
+    return _id;
+}
+
+// SIGNAL 0
+void MainWindow::main_display_signal(VideoUpdate _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 0, _a);
+}
+
+// SIGNAL 1
+void MainWindow::move_host_mouse_signal(MouseMoveUpdate _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 1, _a);
+}
+
+// SIGNAL 2
+void MainWindow::send_nat_rule_to_gui_signal(PortForwardRule _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 2, _a);
+}
+
+// SIGNAL 3
+void MainWindow::error_signal(QString _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 3, _a);
+}
+
+// SIGNAL 4
+void MainWindow::fatal_signal(QString _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 4, _a);
+}
+QT_WARNING_POP
+QT_END_MOC_NAMESPACE
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/moc_nat_edit_dialog.cpp	2021-10-31 18:47:00.000000000 +0000
@@ -0,0 +1,123 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'nat_edit_dialog.h'
+**
+** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.11)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "nat_edit_dialog.h"
+#include <QtCore/qbytearray.h>
+#include <QtCore/qmetatype.h>
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'nat_edit_dialog.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 67
+#error "This file was generated using the moc from 5.12.11. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
+struct qt_meta_stringdata_NatEditDialog_t {
+    QByteArrayData data[4];
+    char stringdata0[47];
+};
+#define QT_MOC_LITERAL(idx, ofs, len) \
+    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
+    qptrdiff(offsetof(qt_meta_stringdata_NatEditDialog_t, stringdata0) + ofs \
+        - idx * sizeof(QByteArrayData)) \
+    )
+static const qt_meta_stringdata_NatEditDialog_t qt_meta_stringdata_NatEditDialog = {
+    {
+QT_MOC_LITERAL(0, 0, 13), // "NatEditDialog"
+QT_MOC_LITERAL(1, 14, 15), // "dialog_accepted"
+QT_MOC_LITERAL(2, 30, 0), // ""
+QT_MOC_LITERAL(3, 31, 15) // "dialog_rejected"
+
+    },
+    "NatEditDialog\0dialog_accepted\0\0"
+    "dialog_rejected"
+};
+#undef QT_MOC_LITERAL
+
+static const uint qt_meta_data_NatEditDialog[] = {
+
+ // content:
+       8,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       2,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: name, argc, parameters, tag, flags
+       1,    0,   24,    2, 0x08 /* Private */,
+       3,    0,   25,    2, 0x08 /* Private */,
+
+ // slots: parameters
+    QMetaType::Void,
+    QMetaType::Void,
+
+       0        // eod
+};
+
+void NatEditDialog::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        auto *_t = static_cast<NatEditDialog *>(_o);
+        Q_UNUSED(_t)
+        switch (_id) {
+        case 0: _t->dialog_accepted(); break;
+        case 1: _t->dialog_rejected(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+QT_INIT_METAOBJECT const QMetaObject NatEditDialog::staticMetaObject = { {
+    &QDialog::staticMetaObject,
+    qt_meta_stringdata_NatEditDialog.data,
+    qt_meta_data_NatEditDialog,
+    qt_static_metacall,
+    nullptr,
+    nullptr
+} };
+
+
+const QMetaObject *NatEditDialog::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
+}
+
+void *NatEditDialog::qt_metacast(const char *_clname)
+{
+    if (!_clname) return nullptr;
+    if (!strcmp(_clname, qt_meta_stringdata_NatEditDialog.stringdata0))
+        return static_cast<void*>(this);
+    return QDialog::qt_metacast(_clname);
+}
+
+int NatEditDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QDialog::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 2)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 2;
+    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
+        if (_id < 2)
+            *reinterpret_cast<int*>(_a[0]) = -1;
+        _id -= 2;
+    }
+    return _id;
+}
+QT_WARNING_POP
+QT_END_MOC_NAMESPACE
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/moc_nat_list_dialog.cpp	2021-10-31 18:47:00.000000000 +0000
@@ -0,0 +1,132 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'nat_list_dialog.h'
+**
+** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.11)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "nat_list_dialog.h"
+#include <QtCore/qbytearray.h>
+#include <QtCore/qmetatype.h>
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'nat_list_dialog.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 67
+#error "This file was generated using the moc from 5.12.11. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
+struct qt_meta_stringdata_NatListDialog_t {
+    QByteArrayData data[6];
+    char stringdata0[89];
+};
+#define QT_MOC_LITERAL(idx, ofs, len) \
+    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
+    qptrdiff(offsetof(qt_meta_stringdata_NatListDialog_t, stringdata0) + ofs \
+        - idx * sizeof(QByteArrayData)) \
+    )
+static const qt_meta_stringdata_NatListDialog_t qt_meta_stringdata_NatListDialog = {
+    {
+QT_MOC_LITERAL(0, 0, 13), // "NatListDialog"
+QT_MOC_LITERAL(1, 14, 15), // "dialog_accepted"
+QT_MOC_LITERAL(2, 30, 0), // ""
+QT_MOC_LITERAL(3, 31, 15), // "dialog_rejected"
+QT_MOC_LITERAL(4, 47, 21), // "delete_button_clicked"
+QT_MOC_LITERAL(5, 69, 19) // "edit_button_clicked"
+
+    },
+    "NatListDialog\0dialog_accepted\0\0"
+    "dialog_rejected\0delete_button_clicked\0"
+    "edit_button_clicked"
+};
+#undef QT_MOC_LITERAL
+
+static const uint qt_meta_data_NatListDialog[] = {
+
+ // content:
+       8,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       4,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: name, argc, parameters, tag, flags
+       1,    0,   34,    2, 0x08 /* Private */,
+       3,    0,   35,    2, 0x08 /* Private */,
+       4,    0,   36,    2, 0x08 /* Private */,
+       5,    0,   37,    2, 0x08 /* Private */,
+
+ // slots: parameters
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+
+       0        // eod
+};
+
+void NatListDialog::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        auto *_t = static_cast<NatListDialog *>(_o);
+        Q_UNUSED(_t)
+        switch (_id) {
+        case 0: _t->dialog_accepted(); break;
+        case 1: _t->dialog_rejected(); break;
+        case 2: _t->delete_button_clicked(); break;
+        case 3: _t->edit_button_clicked(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+QT_INIT_METAOBJECT const QMetaObject NatListDialog::staticMetaObject = { {
+    &QDialog::staticMetaObject,
+    qt_meta_stringdata_NatListDialog.data,
+    qt_meta_data_NatListDialog,
+    qt_static_metacall,
+    nullptr,
+    nullptr
+} };
+
+
+const QMetaObject *NatListDialog::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
+}
+
+void *NatListDialog::qt_metacast(const char *_clname)
+{
+    if (!_clname) return nullptr;
+    if (!strcmp(_clname, qt_meta_stringdata_NatListDialog.stringdata0))
+        return static_cast<void*>(this);
+    return QDialog::qt_metacast(_clname);
+}
+
+int NatListDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QDialog::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 4)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 4;
+    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
+        if (_id < 4)
+            *reinterpret_cast<int*>(_a[0]) = -1;
+        _id -= 4;
+    }
+    return _id;
+}
+QT_WARNING_POP
+QT_END_MOC_NAMESPACE
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/moc_network_dialog.cpp	2021-10-31 18:47:01.000000000 +0000
@@ -0,0 +1,127 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'network_dialog.h'
+**
+** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.11)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "network_dialog.h"
+#include <QtCore/qbytearray.h>
+#include <QtCore/qmetatype.h>
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'network_dialog.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 67
+#error "This file was generated using the moc from 5.12.11. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
+struct qt_meta_stringdata_NetworkDialog_t {
+    QByteArrayData data[5];
+    char stringdata0[61];
+};
+#define QT_MOC_LITERAL(idx, ofs, len) \
+    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
+    qptrdiff(offsetof(qt_meta_stringdata_NetworkDialog_t, stringdata0) + ofs \
+        - idx * sizeof(QByteArrayData)) \
+    )
+static const qt_meta_stringdata_NetworkDialog_t qt_meta_stringdata_NetworkDialog = {
+    {
+QT_MOC_LITERAL(0, 0, 13), // "NetworkDialog"
+QT_MOC_LITERAL(1, 14, 13), // "radio_clicked"
+QT_MOC_LITERAL(2, 28, 0), // ""
+QT_MOC_LITERAL(3, 29, 15), // "dialog_accepted"
+QT_MOC_LITERAL(4, 45, 15) // "dialog_rejected"
+
+    },
+    "NetworkDialog\0radio_clicked\0\0"
+    "dialog_accepted\0dialog_rejected"
+};
+#undef QT_MOC_LITERAL
+
+static const uint qt_meta_data_NetworkDialog[] = {
+
+ // content:
+       8,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       3,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: name, argc, parameters, tag, flags
+       1,    0,   29,    2, 0x08 /* Private */,
+       3,    0,   30,    2, 0x08 /* Private */,
+       4,    0,   31,    2, 0x08 /* Private */,
+
+ // slots: parameters
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+
+       0        // eod
+};
+
+void NetworkDialog::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        auto *_t = static_cast<NetworkDialog *>(_o);
+        Q_UNUSED(_t)
+        switch (_id) {
+        case 0: _t->radio_clicked(); break;
+        case 1: _t->dialog_accepted(); break;
+        case 2: _t->dialog_rejected(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+QT_INIT_METAOBJECT const QMetaObject NetworkDialog::staticMetaObject = { {
+    &QDialog::staticMetaObject,
+    qt_meta_stringdata_NetworkDialog.data,
+    qt_meta_data_NetworkDialog,
+    qt_static_metacall,
+    nullptr,
+    nullptr
+} };
+
+
+const QMetaObject *NetworkDialog::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
+}
+
+void *NetworkDialog::qt_metacast(const char *_clname)
+{
+    if (!_clname) return nullptr;
+    if (!strcmp(_clname, qt_meta_stringdata_NetworkDialog.stringdata0))
+        return static_cast<void*>(this);
+    return QDialog::qt_metacast(_clname);
+}
+
+int NetworkDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QDialog::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 3)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 3;
+    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
+        if (_id < 3)
+            *reinterpret_cast<int*>(_a[0]) = -1;
+        _id -= 3;
+    }
+    return _id;
+}
+QT_WARNING_POP
+QT_END_MOC_NAMESPACE
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/moc_plt_sound.cpp	2021-10-31 18:47:00.000000000 +0000
@@ -0,0 +1,94 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'plt_sound.h'
+**
+** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.11)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "plt_sound.h"
+#include <QtCore/qbytearray.h>
+#include <QtCore/qmetatype.h>
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'plt_sound.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 67
+#error "This file was generated using the moc from 5.12.11. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
+struct qt_meta_stringdata_AudioOut_t {
+    QByteArrayData data[1];
+    char stringdata0[9];
+};
+#define QT_MOC_LITERAL(idx, ofs, len) \
+    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
+    qptrdiff(offsetof(qt_meta_stringdata_AudioOut_t, stringdata0) + ofs \
+        - idx * sizeof(QByteArrayData)) \
+    )
+static const qt_meta_stringdata_AudioOut_t qt_meta_stringdata_AudioOut = {
+    {
+QT_MOC_LITERAL(0, 0, 8) // "AudioOut"
+
+    },
+    "AudioOut"
+};
+#undef QT_MOC_LITERAL
+
+static const uint qt_meta_data_AudioOut[] = {
+
+ // content:
+       8,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       0,    0, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+       0        // eod
+};
+
+void AudioOut::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    Q_UNUSED(_o);
+    Q_UNUSED(_id);
+    Q_UNUSED(_c);
+    Q_UNUSED(_a);
+}
+
+QT_INIT_METAOBJECT const QMetaObject AudioOut::staticMetaObject = { {
+    &QObject::staticMetaObject,
+    qt_meta_stringdata_AudioOut.data,
+    qt_meta_data_AudioOut,
+    qt_static_metacall,
+    nullptr,
+    nullptr
+} };
+
+
+const QMetaObject *AudioOut::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
+}
+
+void *AudioOut::qt_metacast(const char *_clname)
+{
+    if (!_clname) return nullptr;
+    if (!strcmp(_clname, qt_meta_stringdata_AudioOut.stringdata0))
+        return static_cast<void*>(this);
+    return QObject::qt_metacast(_clname);
+}
+
+int AudioOut::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    return _id;
+}
+QT_WARNING_POP
+QT_END_MOC_NAMESPACE
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/qt5/moc_rpc-qt5.cpp	2021-10-31 18:47:00.000000000 +0000
@@ -0,0 +1,766 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'rpc-qt5.h'
+**
+** Created by: The Qt Meta Object Compiler version 67 (Qt 5.12.11)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#include "rpc-qt5.h"
+#include <QtCore/qbytearray.h>
+#include <QtCore/qmetatype.h>
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'rpc-qt5.h' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 67
+#error "This file was generated using the moc from 5.12.11. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+QT_WARNING_PUSH
+QT_WARNING_DISABLE_DEPRECATED
+struct qt_meta_stringdata_Emulator_t {
+    QByteArrayData data[77];
+    char stringdata0[1137];
+};
+#define QT_MOC_LITERAL(idx, ofs, len) \
+    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
+    qptrdiff(offsetof(qt_meta_stringdata_Emulator_t, stringdata0) + ofs \
+        - idx * sizeof(QByteArrayData)) \
+    )
+static const qt_meta_stringdata_Emulator_t qt_meta_stringdata_Emulator = {
+    {
+QT_MOC_LITERAL(0, 0, 8), // "Emulator"
+QT_MOC_LITERAL(1, 9, 8), // "finished"
+QT_MOC_LITERAL(2, 18, 0), // ""
+QT_MOC_LITERAL(3, 19, 20), // "video_flyback_signal"
+QT_MOC_LITERAL(4, 40, 16), // "key_press_signal"
+QT_MOC_LITERAL(5, 57, 9), // "scan_code"
+QT_MOC_LITERAL(6, 67, 18), // "key_release_signal"
+QT_MOC_LITERAL(7, 86, 28), // "modifier_keys_changed_signal"
+QT_MOC_LITERAL(8, 115, 4), // "mask"
+QT_MOC_LITERAL(9, 120, 26), // "modifier_keys_reset_signal"
+QT_MOC_LITERAL(10, 147, 17), // "mouse_move_signal"
+QT_MOC_LITERAL(11, 165, 1), // "x"
+QT_MOC_LITERAL(12, 167, 1), // "y"
+QT_MOC_LITERAL(13, 169, 26), // "mouse_move_relative_signal"
+QT_MOC_LITERAL(14, 196, 2), // "dx"
+QT_MOC_LITERAL(15, 199, 2), // "dy"
+QT_MOC_LITERAL(16, 202, 18), // "mouse_press_signal"
+QT_MOC_LITERAL(17, 221, 7), // "buttons"
+QT_MOC_LITERAL(18, 229, 20), // "mouse_release_signal"
+QT_MOC_LITERAL(19, 250, 12), // "reset_signal"
+QT_MOC_LITERAL(20, 263, 11), // "exit_signal"
+QT_MOC_LITERAL(21, 275, 18), // "load_disc_0_signal"
+QT_MOC_LITERAL(22, 294, 8), // "discname"
+QT_MOC_LITERAL(23, 303, 18), // "load_disc_1_signal"
+QT_MOC_LITERAL(24, 322, 15), // "cpu_idle_signal"
+QT_MOC_LITERAL(25, 338, 21), // "cdrom_disabled_signal"
+QT_MOC_LITERAL(26, 360, 18), // "cdrom_empty_signal"
+QT_MOC_LITERAL(27, 379, 21), // "cdrom_load_iso_signal"
+QT_MOC_LITERAL(28, 401, 18), // "cdrom_ioctl_signal"
+QT_MOC_LITERAL(29, 420, 22), // "cdrom_win_ioctl_signal"
+QT_MOC_LITERAL(30, 443, 12), // "drive_letter"
+QT_MOC_LITERAL(31, 456, 17), // "mouse_hack_signal"
+QT_MOC_LITERAL(32, 474, 22), // "mouse_twobutton_signal"
+QT_MOC_LITERAL(33, 497, 21), // "config_updated_signal"
+QT_MOC_LITERAL(34, 519, 7), // "Config*"
+QT_MOC_LITERAL(35, 527, 10), // "new_config"
+QT_MOC_LITERAL(36, 538, 5), // "Model"
+QT_MOC_LITERAL(37, 544, 9), // "new_model"
+QT_MOC_LITERAL(38, 554, 29), // "network_config_updated_signal"
+QT_MOC_LITERAL(39, 584, 11), // "NetworkType"
+QT_MOC_LITERAL(40, 596, 12), // "network_type"
+QT_MOC_LITERAL(41, 609, 10), // "bridgename"
+QT_MOC_LITERAL(42, 620, 9), // "ipaddress"
+QT_MOC_LITERAL(43, 630, 34), // "show_fullscreen_message_off_s..."
+QT_MOC_LITERAL(44, 665, 19), // "nat_rule_add_signal"
+QT_MOC_LITERAL(45, 685, 15), // "PortForwardRule"
+QT_MOC_LITERAL(46, 701, 4), // "rule"
+QT_MOC_LITERAL(47, 706, 20), // "nat_rule_edit_signal"
+QT_MOC_LITERAL(48, 727, 8), // "old_rule"
+QT_MOC_LITERAL(49, 736, 8), // "new_rule"
+QT_MOC_LITERAL(50, 745, 22), // "nat_rule_remove_signal"
+QT_MOC_LITERAL(51, 768, 11), // "mainemuloop"
+QT_MOC_LITERAL(52, 780, 13), // "video_flyback"
+QT_MOC_LITERAL(53, 794, 9), // "key_press"
+QT_MOC_LITERAL(54, 804, 11), // "key_release"
+QT_MOC_LITERAL(55, 816, 21), // "modifier_keys_changed"
+QT_MOC_LITERAL(56, 838, 19), // "modifier_keys_reset"
+QT_MOC_LITERAL(57, 858, 10), // "mouse_move"
+QT_MOC_LITERAL(58, 869, 19), // "mouse_move_relative"
+QT_MOC_LITERAL(59, 889, 11), // "mouse_press"
+QT_MOC_LITERAL(60, 901, 13), // "mouse_release"
+QT_MOC_LITERAL(61, 915, 5), // "reset"
+QT_MOC_LITERAL(62, 921, 4), // "exit"
+QT_MOC_LITERAL(63, 926, 11), // "load_disc_0"
+QT_MOC_LITERAL(64, 938, 11), // "load_disc_1"
+QT_MOC_LITERAL(65, 950, 8), // "cpu_idle"
+QT_MOC_LITERAL(66, 959, 14), // "cdrom_disabled"
+QT_MOC_LITERAL(67, 974, 11), // "cdrom_empty"
+QT_MOC_LITERAL(68, 986, 14), // "cdrom_load_iso"
+QT_MOC_LITERAL(69, 1001, 10), // "mouse_hack"
+QT_MOC_LITERAL(70, 1012, 15), // "mouse_twobutton"
+QT_MOC_LITERAL(71, 1028, 14), // "config_updated"
+QT_MOC_LITERAL(72, 1043, 22), // "network_config_updated"
+QT_MOC_LITERAL(73, 1066, 27), // "show_fullscreen_message_off"
+QT_MOC_LITERAL(74, 1094, 12), // "nat_rule_add"
+QT_MOC_LITERAL(75, 1107, 13), // "nat_rule_edit"
+QT_MOC_LITERAL(76, 1121, 15) // "nat_rule_remove"
+
+    },
+    "Emulator\0finished\0\0video_flyback_signal\0"
+    "key_press_signal\0scan_code\0"
+    "key_release_signal\0modifier_keys_changed_signal\0"
+    "mask\0modifier_keys_reset_signal\0"
+    "mouse_move_signal\0x\0y\0mouse_move_relative_signal\0"
+    "dx\0dy\0mouse_press_signal\0buttons\0"
+    "mouse_release_signal\0reset_signal\0"
+    "exit_signal\0load_disc_0_signal\0discname\0"
+    "load_disc_1_signal\0cpu_idle_signal\0"
+    "cdrom_disabled_signal\0cdrom_empty_signal\0"
+    "cdrom_load_iso_signal\0cdrom_ioctl_signal\0"
+    "cdrom_win_ioctl_signal\0drive_letter\0"
+    "mouse_hack_signal\0mouse_twobutton_signal\0"
+    "config_updated_signal\0Config*\0new_config\0"
+    "Model\0new_model\0network_config_updated_signal\0"
+    "NetworkType\0network_type\0bridgename\0"
+    "ipaddress\0show_fullscreen_message_off_signal\0"
+    "nat_rule_add_signal\0PortForwardRule\0"
+    "rule\0nat_rule_edit_signal\0old_rule\0"
+    "new_rule\0nat_rule_remove_signal\0"
+    "mainemuloop\0video_flyback\0key_press\0"
+    "key_release\0modifier_keys_changed\0"
+    "modifier_keys_reset\0mouse_move\0"
+    "mouse_move_relative\0mouse_press\0"
+    "mouse_release\0reset\0exit\0load_disc_0\0"
+    "load_disc_1\0cpu_idle\0cdrom_disabled\0"
+    "cdrom_empty\0cdrom_load_iso\0mouse_hack\0"
+    "mouse_twobutton\0config_updated\0"
+    "network_config_updated\0"
+    "show_fullscreen_message_off\0nat_rule_add\0"
+    "nat_rule_edit\0nat_rule_remove"
+};
+#undef QT_MOC_LITERAL
+
+static const uint qt_meta_data_Emulator[] = {
+
+ // content:
+       8,       // revision
+       0,       // classname
+       0,    0, // classinfo
+      54,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+      28,       // signalCount
+
+ // signals: name, argc, parameters, tag, flags
+       1,    0,  284,    2, 0x06 /* Public */,
+       3,    0,  285,    2, 0x06 /* Public */,
+       4,    1,  286,    2, 0x06 /* Public */,
+       6,    1,  289,    2, 0x06 /* Public */,
+       7,    1,  292,    2, 0x06 /* Public */,
+       9,    0,  295,    2, 0x06 /* Public */,
+      10,    2,  296,    2, 0x06 /* Public */,
+      13,    2,  301,    2, 0x06 /* Public */,
+      16,    1,  306,    2, 0x06 /* Public */,
+      18,    1,  309,    2, 0x06 /* Public */,
+      19,    0,  312,    2, 0x06 /* Public */,
+      20,    0,  313,    2, 0x06 /* Public */,
+      21,    1,  314,    2, 0x06 /* Public */,
+      23,    1,  317,    2, 0x06 /* Public */,
+      24,    0,  320,    2, 0x06 /* Public */,
+      25,    0,  321,    2, 0x06 /* Public */,
+      26,    0,  322,    2, 0x06 /* Public */,
+      27,    1,  323,    2, 0x06 /* Public */,
+      28,    0,  326,    2, 0x06 /* Public */,
+      29,    1,  327,    2, 0x06 /* Public */,
+      31,    0,  330,    2, 0x06 /* Public */,
+      32,    0,  331,    2, 0x06 /* Public */,
+      33,    2,  332,    2, 0x06 /* Public */,
+      38,    3,  337,    2, 0x06 /* Public */,
+      43,    0,  344,    2, 0x06 /* Public */,
+      44,    1,  345,    2, 0x06 /* Public */,
+      47,    2,  348,    2, 0x06 /* Public */,
+      50,    1,  353,    2, 0x06 /* Public */,
+
+ // slots: name, argc, parameters, tag, flags
+      51,    0,  356,    2, 0x0a /* Public */,
+      52,    0,  357,    2, 0x0a /* Public */,
+      53,    1,  358,    2, 0x0a /* Public */,
+      54,    1,  361,    2, 0x0a /* Public */,
+      55,    1,  364,    2, 0x0a /* Public */,
+      56,    0,  367,    2, 0x0a /* Public */,
+      57,    2,  368,    2, 0x0a /* Public */,
+      58,    2,  373,    2, 0x0a /* Public */,
+      59,    1,  378,    2, 0x0a /* Public */,
+      60,    1,  381,    2, 0x0a /* Public */,
+      61,    0,  384,    2, 0x0a /* Public */,
+      62,    0,  385,    2, 0x0a /* Public */,
+      63,    1,  386,    2, 0x0a /* Public */,
+      64,    1,  389,    2, 0x0a /* Public */,
+      65,    0,  392,    2, 0x0a /* Public */,
+      66,    0,  393,    2, 0x0a /* Public */,
+      67,    0,  394,    2, 0x0a /* Public */,
+      68,    1,  395,    2, 0x0a /* Public */,
+      69,    0,  398,    2, 0x0a /* Public */,
+      70,    0,  399,    2, 0x0a /* Public */,
+      71,    2,  400,    2, 0x0a /* Public */,
+      72,    3,  405,    2, 0x0a /* Public */,
+      73,    0,  412,    2, 0x0a /* Public */,
+      74,    1,  413,    2, 0x0a /* Public */,
+      75,    2,  416,    2, 0x0a /* Public */,
+      76,    1,  421,    2, 0x0a /* Public */,
+
+ // signals: parameters
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void, QMetaType::UInt,    5,
+    QMetaType::Void, QMetaType::UInt,    5,
+    QMetaType::Void, QMetaType::UInt,    8,
+    QMetaType::Void,
+    QMetaType::Void, QMetaType::Int, QMetaType::Int,   11,   12,
+    QMetaType::Void, QMetaType::Int, QMetaType::Int,   14,   15,
+    QMetaType::Void, QMetaType::Int,   17,
+    QMetaType::Void, QMetaType::Int,   17,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void, QMetaType::QString,   22,
+    QMetaType::Void, QMetaType::QString,   22,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void, QMetaType::QString,   22,
+    QMetaType::Void,
+    QMetaType::Void, QMetaType::Char,   30,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void, 0x80000000 | 34, 0x80000000 | 36,   35,   37,
+    QMetaType::Void, 0x80000000 | 39, QMetaType::QString, QMetaType::QString,   40,   41,   42,
+    QMetaType::Void,
+    QMetaType::Void, 0x80000000 | 45,   46,
+    QMetaType::Void, 0x80000000 | 45, 0x80000000 | 45,   48,   49,
+    QMetaType::Void, 0x80000000 | 45,   46,
+
+ // slots: parameters
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void, QMetaType::UInt,    5,
+    QMetaType::Void, QMetaType::UInt,    5,
+    QMetaType::Void, QMetaType::UInt,    8,
+    QMetaType::Void,
+    QMetaType::Void, QMetaType::Int, QMetaType::Int,   11,   12,
+    QMetaType::Void, QMetaType::Int, QMetaType::Int,   14,   15,
+    QMetaType::Void, QMetaType::Int,   17,
+    QMetaType::Void, QMetaType::Int,   17,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void, QMetaType::QString,   22,
+    QMetaType::Void, QMetaType::QString,   22,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void, QMetaType::QString,   22,
+    QMetaType::Void,
+    QMetaType::Void,
+    QMetaType::Void, 0x80000000 | 34, 0x80000000 | 36,   35,   37,
+    QMetaType::Void, 0x80000000 | 39, QMetaType::QString, QMetaType::QString,   40,   41,   42,
+    QMetaType::Void,
+    QMetaType::Void, 0x80000000 | 45,   46,
+    QMetaType::Void, 0x80000000 | 45, 0x80000000 | 45,   48,   49,
+    QMetaType::Void, 0x80000000 | 45,   46,
+
+       0        // eod
+};
+
+void Emulator::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        auto *_t = static_cast<Emulator *>(_o);
+        Q_UNUSED(_t)
+        switch (_id) {
+        case 0: _t->finished(); break;
+        case 1: _t->video_flyback_signal(); break;
+        case 2: _t->key_press_signal((*reinterpret_cast< uint(*)>(_a[1]))); break;
+        case 3: _t->key_release_signal((*reinterpret_cast< uint(*)>(_a[1]))); break;
+        case 4: _t->modifier_keys_changed_signal((*reinterpret_cast< uint(*)>(_a[1]))); break;
+        case 5: _t->modifier_keys_reset_signal(); break;
+        case 6: _t->mouse_move_signal((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
+        case 7: _t->mouse_move_relative_signal((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
+        case 8: _t->mouse_press_signal((*reinterpret_cast< int(*)>(_a[1]))); break;
+        case 9: _t->mouse_release_signal((*reinterpret_cast< int(*)>(_a[1]))); break;
+        case 10: _t->reset_signal(); break;
+        case 11: _t->exit_signal(); break;
+        case 12: _t->load_disc_0_signal((*reinterpret_cast< QString(*)>(_a[1]))); break;
+        case 13: _t->load_disc_1_signal((*reinterpret_cast< QString(*)>(_a[1]))); break;
+        case 14: _t->cpu_idle_signal(); break;
+        case 15: _t->cdrom_disabled_signal(); break;
+        case 16: _t->cdrom_empty_signal(); break;
+        case 17: _t->cdrom_load_iso_signal((*reinterpret_cast< const QString(*)>(_a[1]))); break;
+        case 18: _t->cdrom_ioctl_signal(); break;
+        case 19: _t->cdrom_win_ioctl_signal((*reinterpret_cast< char(*)>(_a[1]))); break;
+        case 20: _t->mouse_hack_signal(); break;
+        case 21: _t->mouse_twobutton_signal(); break;
+        case 22: _t->config_updated_signal((*reinterpret_cast< Config*(*)>(_a[1])),(*reinterpret_cast< Model(*)>(_a[2]))); break;
+        case 23: _t->network_config_updated_signal((*reinterpret_cast< NetworkType(*)>(_a[1])),(*reinterpret_cast< QString(*)>(_a[2])),(*reinterpret_cast< QString(*)>(_a[3]))); break;
+        case 24: _t->show_fullscreen_message_off_signal(); break;
+        case 25: _t->nat_rule_add_signal((*reinterpret_cast< PortForwardRule(*)>(_a[1]))); break;
+        case 26: _t->nat_rule_edit_signal((*reinterpret_cast< PortForwardRule(*)>(_a[1])),(*reinterpret_cast< PortForwardRule(*)>(_a[2]))); break;
+        case 27: _t->nat_rule_remove_signal((*reinterpret_cast< PortForwardRule(*)>(_a[1]))); break;
+        case 28: _t->mainemuloop(); break;
+        case 29: _t->video_flyback(); break;
+        case 30: _t->key_press((*reinterpret_cast< uint(*)>(_a[1]))); break;
+        case 31: _t->key_release((*reinterpret_cast< uint(*)>(_a[1]))); break;
+        case 32: _t->modifier_keys_changed((*reinterpret_cast< uint(*)>(_a[1]))); break;
+        case 33: _t->modifier_keys_reset(); break;
+        case 34: _t->mouse_move((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
+        case 35: _t->mouse_move_relative((*reinterpret_cast< int(*)>(_a[1])),(*reinterpret_cast< int(*)>(_a[2]))); break;
+        case 36: _t->mouse_press((*reinterpret_cast< int(*)>(_a[1]))); break;
+        case 37: _t->mouse_release((*reinterpret_cast< int(*)>(_a[1]))); break;
+        case 38: _t->reset(); break;
+        case 39: _t->exit(); break;
+        case 40: _t->load_disc_0((*reinterpret_cast< QString(*)>(_a[1]))); break;
+        case 41: _t->load_disc_1((*reinterpret_cast< QString(*)>(_a[1]))); break;
+        case 42: _t->cpu_idle(); break;
+        case 43: _t->cdrom_disabled(); break;
+        case 44: _t->cdrom_empty(); break;
+        case 45: _t->cdrom_load_iso((*reinterpret_cast< QString(*)>(_a[1]))); break;
+        case 46: _t->mouse_hack(); break;
+        case 47: _t->mouse_twobutton(); break;
+        case 48: _t->config_updated((*reinterpret_cast< Config*(*)>(_a[1])),(*reinterpret_cast< Model(*)>(_a[2]))); break;
+        case 49: _t->network_config_updated((*reinterpret_cast< NetworkType(*)>(_a[1])),(*reinterpret_cast< QString(*)>(_a[2])),(*reinterpret_cast< QString(*)>(_a[3]))); break;
+        case 50: _t->show_fullscreen_message_off(); break;
+        case 51: _t->nat_rule_add((*reinterpret_cast< PortForwardRule(*)>(_a[1]))); break;
+        case 52: _t->nat_rule_edit((*reinterpret_cast< PortForwardRule(*)>(_a[1])),(*reinterpret_cast< PortForwardRule(*)>(_a[2]))); break;
+        case 53: _t->nat_rule_remove((*reinterpret_cast< PortForwardRule(*)>(_a[1]))); break;
+        default: ;
+        }
+    } else if (_c == QMetaObject::IndexOfMethod) {
+        int *result = reinterpret_cast<int *>(_a[0]);
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::finished)) {
+                *result = 0;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::video_flyback_signal)) {
+                *result = 1;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(unsigned  );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::key_press_signal)) {
+                *result = 2;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(unsigned  );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::key_release_signal)) {
+                *result = 3;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(unsigned  );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::modifier_keys_changed_signal)) {
+                *result = 4;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::modifier_keys_reset_signal)) {
+                *result = 5;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(int , int );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::mouse_move_signal)) {
+                *result = 6;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(int , int );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::mouse_move_relative_signal)) {
+                *result = 7;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(int );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::mouse_press_signal)) {
+                *result = 8;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(int );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::mouse_release_signal)) {
+                *result = 9;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::reset_signal)) {
+                *result = 10;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::exit_signal)) {
+                *result = 11;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(QString );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::load_disc_0_signal)) {
+                *result = 12;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(QString );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::load_disc_1_signal)) {
+                *result = 13;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::cpu_idle_signal)) {
+                *result = 14;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::cdrom_disabled_signal)) {
+                *result = 15;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::cdrom_empty_signal)) {
+                *result = 16;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(const QString & );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::cdrom_load_iso_signal)) {
+                *result = 17;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::cdrom_ioctl_signal)) {
+                *result = 18;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(char );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::cdrom_win_ioctl_signal)) {
+                *result = 19;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::mouse_hack_signal)) {
+                *result = 20;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::mouse_twobutton_signal)) {
+                *result = 21;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(Config * , Model );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::config_updated_signal)) {
+                *result = 22;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(NetworkType , QString , QString );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::network_config_updated_signal)) {
+                *result = 23;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)();
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::show_fullscreen_message_off_signal)) {
+                *result = 24;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(PortForwardRule );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::nat_rule_add_signal)) {
+                *result = 25;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(PortForwardRule , PortForwardRule );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::nat_rule_edit_signal)) {
+                *result = 26;
+                return;
+            }
+        }
+        {
+            using _t = void (Emulator::*)(PortForwardRule );
+            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Emulator::nat_rule_remove_signal)) {
+                *result = 27;
+                return;
+            }
+        }
+    }
+}
+
+QT_INIT_METAOBJECT const QMetaObject Emulator::staticMetaObject = { {
+    &QObject::staticMetaObject,
+    qt_meta_stringdata_Emulator.data,
+    qt_meta_data_Emulator,
+    qt_static_metacall,
+    nullptr,
+    nullptr
+} };
+
+
+const QMetaObject *Emulator::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
+}
+
+void *Emulator::qt_metacast(const char *_clname)
+{
+    if (!_clname) return nullptr;
+    if (!strcmp(_clname, qt_meta_stringdata_Emulator.stringdata0))
+        return static_cast<void*>(this);
+    return QObject::qt_metacast(_clname);
+}
+
+int Emulator::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 54)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 54;
+    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
+        if (_id < 54)
+            *reinterpret_cast<int*>(_a[0]) = -1;
+        _id -= 54;
+    }
+    return _id;
+}
+
+// SIGNAL 0
+void Emulator::finished()
+{
+    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
+}
+
+// SIGNAL 1
+void Emulator::video_flyback_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 1, nullptr);
+}
+
+// SIGNAL 2
+void Emulator::key_press_signal(unsigned  _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 2, _a);
+}
+
+// SIGNAL 3
+void Emulator::key_release_signal(unsigned  _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 3, _a);
+}
+
+// SIGNAL 4
+void Emulator::modifier_keys_changed_signal(unsigned  _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 4, _a);
+}
+
+// SIGNAL 5
+void Emulator::modifier_keys_reset_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 5, nullptr);
+}
+
+// SIGNAL 6
+void Emulator::mouse_move_signal(int _t1, int _t2)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)), const_cast<void*>(reinterpret_cast<const void*>(&_t2)) };
+    QMetaObject::activate(this, &staticMetaObject, 6, _a);
+}
+
+// SIGNAL 7
+void Emulator::mouse_move_relative_signal(int _t1, int _t2)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)), const_cast<void*>(reinterpret_cast<const void*>(&_t2)) };
+    QMetaObject::activate(this, &staticMetaObject, 7, _a);
+}
+
+// SIGNAL 8
+void Emulator::mouse_press_signal(int _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 8, _a);
+}
+
+// SIGNAL 9
+void Emulator::mouse_release_signal(int _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 9, _a);
+}
+
+// SIGNAL 10
+void Emulator::reset_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 10, nullptr);
+}
+
+// SIGNAL 11
+void Emulator::exit_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 11, nullptr);
+}
+
+// SIGNAL 12
+void Emulator::load_disc_0_signal(QString _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 12, _a);
+}
+
+// SIGNAL 13
+void Emulator::load_disc_1_signal(QString _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 13, _a);
+}
+
+// SIGNAL 14
+void Emulator::cpu_idle_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 14, nullptr);
+}
+
+// SIGNAL 15
+void Emulator::cdrom_disabled_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 15, nullptr);
+}
+
+// SIGNAL 16
+void Emulator::cdrom_empty_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 16, nullptr);
+}
+
+// SIGNAL 17
+void Emulator::cdrom_load_iso_signal(const QString & _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 17, _a);
+}
+
+// SIGNAL 18
+void Emulator::cdrom_ioctl_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 18, nullptr);
+}
+
+// SIGNAL 19
+void Emulator::cdrom_win_ioctl_signal(char _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 19, _a);
+}
+
+// SIGNAL 20
+void Emulator::mouse_hack_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 20, nullptr);
+}
+
+// SIGNAL 21
+void Emulator::mouse_twobutton_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 21, nullptr);
+}
+
+// SIGNAL 22
+void Emulator::config_updated_signal(Config * _t1, Model _t2)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)), const_cast<void*>(reinterpret_cast<const void*>(&_t2)) };
+    QMetaObject::activate(this, &staticMetaObject, 22, _a);
+}
+
+// SIGNAL 23
+void Emulator::network_config_updated_signal(NetworkType _t1, QString _t2, QString _t3)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)), const_cast<void*>(reinterpret_cast<const void*>(&_t2)), const_cast<void*>(reinterpret_cast<const void*>(&_t3)) };
+    QMetaObject::activate(this, &staticMetaObject, 23, _a);
+}
+
+// SIGNAL 24
+void Emulator::show_fullscreen_message_off_signal()
+{
+    QMetaObject::activate(this, &staticMetaObject, 24, nullptr);
+}
+
+// SIGNAL 25
+void Emulator::nat_rule_add_signal(PortForwardRule _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 25, _a);
+}
+
+// SIGNAL 26
+void Emulator::nat_rule_edit_signal(PortForwardRule _t1, PortForwardRule _t2)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)), const_cast<void*>(reinterpret_cast<const void*>(&_t2)) };
+    QMetaObject::activate(this, &staticMetaObject, 26, _a);
+}
+
+// SIGNAL 27
+void Emulator::nat_rule_remove_signal(PortForwardRule _t1)
+{
+    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
+    QMetaObject::activate(this, &staticMetaObject, 27, _a);
+}
+QT_WARNING_POP
+QT_END_MOC_NAMESPACE
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/macosx/network-macosx.c	2021-10-31 11:59:49.000000000 +0000
@@ -0,0 +1,97 @@
+/*
+  RPCEmu - An Acorn system emulator
+
+  Copyright (C) 2005-2010 Sarah Walker
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/* RPCemu networking */
+
+#include <assert.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <net/if.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <pwd.h>
+#include <grp.h>
+#include <signal.h>
+
+#include "rpcemu.h"
+#include "mem.h"
+#include "podules.h"
+#include "network.h"
+
+int
+network_plt_init(void)
+{
+    // Do nothing on a Mac, as TUN/TAP is not supported.
+    return 0;
+}
+
+/**
+ * Shutdown any running network components.
+ *
+ * Called on program shutdown and program reset after
+ * configuration has changed.
+ */
+void
+network_plt_reset(void)
+{
+    // Do nothing on a Mac, as TUN/TAP is not supported.
+}
+
+uint32_t
+network_plt_rx(uint32_t errbuf, uint32_t mbuf, uint32_t rxhdr, uint32_t *dataavail)
+{
+    NOT_USED(errbuf);
+    NOT_USED(mbuf);
+    NOT_USED(rxhdr);
+    NOT_USED(dataavail);
+    
+    // Do nothing on a Mac, as TUN/TAP is not supported.
+    return 0;
+}
+
+uint32_t
+network_plt_tx(uint32_t errbuf, uint32_t mbufs, uint32_t dest, uint32_t src, uint32_t frametype)
+{
+    NOT_USED(errbuf);
+    NOT_USED(mbufs);
+    NOT_USED(dest);
+    NOT_USED(src);
+    NOT_USED(frametype);
+
+    // Do nothing on a Mac, as TUN/TAP is not supported.
+    return 0;
+}
+
+void
+network_plt_setirqstatus(uint32_t address)
+{
+    NOT_USED(address);
+    
+    // Do nothing on a Mac, as TUN/TAP is not supported.
+}
--- original/network.c	2021-10-28 16:57:41.000000000 +0100
+++ src/network.c	2021-11-01 19:29:13.000000000 +0000
@@ -74,6 +74,7 @@
 {
 	FILE *f;
 	size_t module_file_size = 0;
+    char filename[512];
 
 	// Build podule header
 	chunkbase = 0x10;
@@ -81,7 +82,10 @@
 	poduleromsize = filebase + ((sizeof(description) + 3) & ~3u); // Word align description string
 
 	// Add on size for driver module if it can be opened successfully
-	f = fopen("netroms/EtherRPCEm,ffa", "rb");
+    snprintf(filename,sizeof(filename), "%snetroms/EtherRPCEm,ffa", rpcemu_get_datadir());
+    rpclog("network_rom_init: Attempting to load Ethernet ROM from '%s'\n", filename);
+    
+	f = fopen(filename, "rb");
 	if (f != NULL) {
 		long len;
 
@@ -125,6 +129,8 @@
 			len = (len + 3) & ~3u;
 			makechunk(0x81, filebase, (uint32_t) len); // 0x81 = RISC OS, ROM
 		}
+        
+        rpclog("network_rom_init: Successfuly loaded 'EtherRPCEm,ffa' into podulerom\n");
 	}
 }
 
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/macosx/preferences-macosx.h	2021-10-31 11:59:49.000000000 +0000
@@ -0,0 +1,38 @@
+///*
+// RPCEmu - An Acorn system emulator
+//
+// Copyright (C) 2017 Matthew Howkins
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+// */
+
+#ifndef __PREFERENCES_MACOSX_H__
+#define __PREFERENCES_MACOSX_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern void init_preferences(void);
+extern void preferences_set_data_directory(const char *path);
+extern const char *preferences_get_data_directory();
+
+extern bool promptForDataDirectory;
+  
+#ifdef __cplusplus
+}
+#endif
+
+#endif // __PREFERENCES_MACOSX_H__
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/macosx/preferences-macosx.m	2021-10-31 11:59:49.000000000 +0000
@@ -0,0 +1,86 @@
+/*
+ RPCEmu - An Acorn system emulator
+ 
+ Copyright (C) 2017 Matthew Howkins
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define UNUSED(x) (void)(x)
+
+#include <stddef.h>
+#include <stdint.h>
+#include <dirent.h>
+
+#include <Cocoa/Cocoa.h>
+#include <Carbon/Carbon.h>
+#include <IOKit/hid/IOHIDLib.h>
+
+#include "rpcemu.h"
+
+bool promptForDataDirectory;
+NSString* const KeyDataDirectory = @"DataDirectory";
+
+void init_preferences(void)
+{
+  NSMutableDictionary *defaultValues = [NSMutableDictionary dictionary];
+  [defaultValues setObject: @"" forKey:KeyDataDirectory];
+  
+  [[NSUserDefaults standardUserDefaults] registerDefaults: defaultValues];
+  
+  NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
+  
+  // Check to see if there is a proper path for the data directory.
+  // If not, prompt for one.
+  NSString *dataDirectory = [defaults stringForKey: KeyDataDirectory];
+  if (dataDirectory == nil || [dataDirectory length] == 0)
+  {
+    promptForDataDirectory = true;
+  }
+  else
+  {
+    const char *str = [dataDirectory UTF8String];
+
+    // Check the folder exists.
+    DIR *ptr = opendir(str);
+    if (ptr)
+    {
+      closedir(ptr);
+      rpcemu_set_datadir(str);
+      
+      promptForDataDirectory = false;
+    }
+    else
+    {
+      promptForDataDirectory = true;
+    }
+  }
+}
+
+void preferences_set_data_directory(const char *path)
+{
+  NSString *dataDirectory = [NSString stringWithUTF8String: path];
+  
+  NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
+  [defaults setObject:dataDirectory forKey:KeyDataDirectory];
+}
+
+const char* preferences_get_data_directory()
+{
+  NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
+  NSString *path = [defaults stringForKey: KeyDataDirectory];
+  
+  return [path UTF8String];
+}
--- original/rpc-machdep.c	2021-10-31 13:28:31.000000000 +0000
+++ src/rpc-machdep.c	2021-11-01 19:29:13.000000000 +0000
@@ -26,7 +26,39 @@
    be, but currently this version is used by Linux, all the other autoconf
    based builds and Windows. Only Mac OS X GUI version needs to override */
 
-static char datadir[512] = "/Users/Timothy/Public/Projects/RPCEmu/originals/0.9.4/";
+#ifdef __APPLE__
+#include <dirent.h>
+
+static char datadir[512] = "";
+
+int rpcemu_set_datadir(const char *path)
+{
+  int len = strlen(path);
+  if (len == 0) return 0;
+
+  if (path[len - 1] != '/')
+  {
+    snprintf(datadir, 512, "%s/", path);
+  }
+  else
+  {
+    strncpy(datadir, path, 512);
+  }
+
+  DIR *ptr = opendir(datadir);
+  if (ptr)
+  {
+    closedir(ptr);
+    return 1;
+  }
+
+  return 0;
+}
+
+#else
+static char datadir[512] = "./";
+#endif
+
 static char logpath[1024] = "";
 
 /**
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/rpc-macosx.c	2021-10-31 12:05:27.000000000 +0000
@@ -0,0 +1,87 @@
+/*
+  RPCEmu - An Acorn system emulator
+
+  Copyright (C) 2005-2010 Sarah Walker
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+
+#include <pthread.h>
+#include <sys/statvfs.h>
+#include <sys/types.h>
+#include <sys/utsname.h>
+#include <sys/wait.h>
+
+#include "rpcemu.h"
+#include "mem.h"
+#include "sound.h"
+#include "vidc20.h"
+
+
+
+
+/**
+ * Return disk space information about a file system.
+ *
+ * @param path Pathname of object within file system
+ * @param d    Pointer to disk_info structure that will be filled in
+ * @return     On success 1 is returned, on error 0 is returned
+ */
+int
+path_disk_info(const char *path, disk_info *d)
+{
+    struct statvfs s;
+    int ret;
+
+    assert(path != NULL);
+    assert(d != NULL);
+
+    if ((ret = statvfs(path, &s)) != 0) {
+        return 0;
+    }
+
+    d->size = (uint64_t) s.f_blocks * (uint64_t) s.f_frsize;
+    d->free = (uint64_t) s.f_bavail * (uint64_t) s.f_frsize;
+
+    return 1;
+}
+
+/**
+ * Log details about the current Operating System version.
+ *
+ * This function should work on all Unix and Unix-like systems.
+ *
+ * Called during program start-up.
+ */
+void
+rpcemu_log_os(void)
+{
+    struct utsname u;
+
+    if (uname(&u) == -1) {
+        rpclog("OS: Could not determine: %s\n", strerror(errno));
+        return;
+    }
+
+    rpclog("OS: SysName = %s\n", u.sysname);
+    rpclog("OS: Release = %s\n", u.release);
+    rpclog("OS: Version = %s\n", u.version);
+    rpclog("OS: Machine = %s\n", u.machine);
+}
--- original/qt5/rpc-qt5.cpp	2021-10-31 13:25:34.000000000 +0000
+++ src/qt5/rpc-qt5.cpp	2021-11-01 19:29:13.000000000 +0000
@@ -47,6 +47,15 @@
 #include "network.h"
 #include "network-nat.h"
 
+#if defined(Q_OS_MACOS)
+#include "choose_dialog.h"
+
+#include "macosx/preferences-macosx.h"
+#include "macosx/hid-macosx.h"
+
+#include "keyboard_macosx.h"
+#endif /* Q_OS_MACOS */
+
 #if defined(Q_OS_WIN32)
 #include "cdrom-ioctl.h"
 
@@ -416,6 +425,23 @@
 
 } // extern "C"
 
+#if defined(Q_OS_MACOS)
+
+int rpcemu_choose_datadirectory()
+{
+  ChooseDialog dialog;
+  if (dialog.exec() == QDialog::Accepted)
+  {
+    const char *path = preferences_get_data_directory();
+
+      return rpcemu_set_datadir(path);
+  }
+
+  return 0;
+}
+
+#endif
+
 /**
  * Program entry point
  *
@@ -434,6 +460,20 @@
 
 	// Add a program icon
 	QApplication::setWindowIcon(QIcon(":/rpcemu_icon.png"));
+    
+#if defined(Q_OS_MACOS)
+    init_preferences();
+
+    // If there is not a data directory in the application preferences, prompt for one.
+    // This will also prompt if the "Shift" key is held down while the application loads.
+    if (promptForDataDirectory || (QApplication::queryKeyboardModifiers() & Qt::ShiftModifier) != 0)
+    {
+        if (!rpcemu_choose_datadirectory())
+        {
+            return 0;
+        }
+    }
+#endif
 	
 	// start enough of the emulator system to allow
 	// the GUI to initialise (e.g. load the config to init
@@ -457,6 +497,11 @@
 	QThread::connect(emulator, &Emulator::finished, emu_thread, &QThread::quit);
 	QThread::connect(emulator, &Emulator::finished, emulator, &Emulator::deleteLater);
 	QThread::connect(emu_thread, &QThread::finished, emu_thread, &QThread::deleteLater);
+    
+#if defined(Q_OS_MACOS)
+    // Initialise the HID manager for CAPS LOCK key events.
+    init_hid_manager();
+#endif
 
 	// Create Main Window
 	MainWindow main_window(*emulator);
@@ -495,6 +540,14 @@
 
 	connect(this, &Emulator::key_release_signal,
 	        this, &Emulator::key_release);
+    
+#if defined(Q_OS_MACOS)
+    // Modifier keys on a Mac must be handled separately, as there is no way of telling
+    // left or right from the key press and key release events due to a lack of scan codes.
+
+    connect(this, &Emulator::modifier_keys_changed_signal, this, &Emulator::modifier_keys_changed);
+    connect(this, &Emulator::modifier_keys_reset_signal, this, &Emulator::modifier_keys_reset);
+#endif /* Q_OS_MACOS */
 
 	connect(this, &Emulator::mouse_move_signal, this, &Emulator::mouse_move);
 	connect(this, &Emulator::mouse_move_relative_signal, this, &Emulator::mouse_move_relative);
@@ -584,7 +637,7 @@
 		if (config.network_type == NetworkType_NAT) {
 			network_nat_rate++;
 			if ((network_nat_rate & 0x3) == 0) {
-//				network_nat_poll();
+				network_nat_poll();
 			}
 		}
 	}
@@ -667,6 +720,27 @@
 	keyboard_key_release(scan_codes);
 }
 
+#if defined(Q_OS_MACOS)
+
+/**
+ * Modifier keys changed
+ * @param mask The modifier key mask from the original NSEvent
+ */
+void Emulator::modifier_keys_changed(unsigned mask)
+{
+    keyboard_handle_modifier_keys(mask);
+}
+
+/**
+ * Modifier keys reset
+ */
+void Emulator::modifier_keys_reset()
+{
+    keyboard_reset_modifiers(true);
+}
+
+#endif /* Q_OS_MACOS */
+
 /**
  * Mouse has moved in absolute position (mousehack mode)
  * 
@@ -961,9 +1035,9 @@
 	QByteArray ba_ipaddress = ipaddress.toUtf8();
 	const char *ip_address = ba_ipaddress.constData();
 
-//	if (network_config_changed(network_type, bridge_name, ip_address)) {
-//		this->reset();
-//	}
+	if (network_config_changed(network_type, bridge_name, ip_address)) {
+		this->reset();
+	}
 }
 
 /**
@@ -987,10 +1061,10 @@
 Emulator::nat_rule_add(PortForwardRule rule)
 {
 	// Activate the rule changes
-//	network_nat_forward_add(rule);
+	network_nat_forward_add(rule);
 
 	// Update the stored list of rules
-//	rpcemu_nat_forward_add(rule);
+	rpcemu_nat_forward_add(rule);
 
 	// Save the settings to the rpc.cfg file
 	config_save(&config);
@@ -1006,14 +1080,14 @@
 Emulator::nat_rule_edit(PortForwardRule old_rule, PortForwardRule new_rule)
 {
 	// Activate the rule changes
-//	network_nat_forward_edit(old_rule, new_rule);
+	network_nat_forward_edit(old_rule, new_rule);
 
 	// Update the stored list of rules
-//	rpcemu_nat_forward_remove(old_rule);
-//	rpcemu_nat_forward_add(new_rule);
+	rpcemu_nat_forward_remove(old_rule);
+	rpcemu_nat_forward_add(new_rule);
 
 	// Save the settings to the rpc.cfg file
-//	config_save(&config);
+	config_save(&config);
 }
 
 /**
@@ -1025,13 +1099,13 @@
 Emulator::nat_rule_remove(PortForwardRule rule)
 {
 	// Activate the rule changes
-//	network_nat_forward_remove(rule);
+	network_nat_forward_remove(rule);
 
 	// Update the stored list of rules
-//	rpcemu_nat_forward_remove(rule);
+	rpcemu_nat_forward_remove(rule);
 
 	// Save the settings to the rpc.cfg file
-//	config_save(&config);
+	config_save(&config);
 }
 
 #ifdef __cplusplus
--- original/qt5/rpc-qt5.h	2021-10-28 16:57:41.000000000 +0100
+++ src/qt5/rpc-qt5.h	2021-11-01 19:29:13.000000000 +0000
@@ -51,7 +51,12 @@
 	void key_press_signal(unsigned scan_code);
 
 	void key_release_signal(unsigned scan_code);
-
+    
+#if defined(Q_OS_MACOS)
+    void modifier_keys_changed_signal(unsigned mask);
+    void modifier_keys_reset_signal();
+#endif /* Q_OS_MACOS */
+    
 	void mouse_move_signal(int x, int y);
 	void mouse_move_relative_signal(int dx, int dy);
 	void mouse_press_signal(int buttons);
@@ -85,7 +90,12 @@
 	void key_press(unsigned scan_code);
 
 	void key_release(unsigned scan_code);
-
+   
+#if defined(Q_OS_MACOS)
+    void modifier_keys_changed(unsigned mask);
+    void modifier_keys_reset();
+#endif /* Q_OS_MACOS */
+    
 	void mouse_move(int x, int y);
 	void mouse_move_relative(int dx, int dy);
 	void mouse_press(int buttons);
--- original/rpcemu.h	2021-10-31 13:22:31.000000000 +0000
+++ src/rpcemu.h	2021-11-01 19:29:13.000000000 +0000
@@ -72,8 +72,8 @@
 /* Note that networking is currently supported on Mac OS X with the Cocoa GUI
    version but not with the Allegro GUI. */
 #if defined __linux || defined __linux__ || defined WIN32 || defined _WIN32 || \
-    defined RPCEMU_COCOA_GUI
-// #define RPCEMU_NETWORKING
+    defined RPCEMU_COCOA_GUI || __APPLE__
+#define RPCEMU_NETWORKING
 #endif
 
 /*This makes the RISC OS mouse pointer follow the host pointer exactly. Useful
@@ -183,6 +183,10 @@
 
 extern uint32_t inscount;
 
+#ifdef __APPLE__
+extern int rpcemu_set_datadir(const char *path);
+#endif
+
 /* These functions can optionally be overridden by a platform. If not
    needed to be overridden, there is a generic version in rpc-machdep.c */
 extern const char *rpcemu_get_datadir(void);
--- original/qt5/rpcemu.pro	2021-10-31 13:22:03.000000000 +0000
+++ src/qt5/rpcemu.pro	2021-11-01 19:29:13.000000000 +0000
@@ -6,6 +6,10 @@
 QT += core widgets gui multimedia
 INCLUDEPATH += ../
 
+macx {
+  INCLUDEPATH += ../macosx
+}
+
 # -Werror=switch
 #	Ensures that using switch with enum requires every value to be handled
 # -fno-common
@@ -74,7 +78,7 @@
 		plt_sound.cpp
 
 # NAT Networking
-linux | win32 {
+linux | win32 | macx {
 	HEADERS +=	../network-nat.h \
 			nat_edit_dialog.h \
 			nat_list_dialog.h
@@ -158,10 +162,37 @@
 			network_dialog.h
 }
 
-unix {
+!macx {
+  unix {
 	SOURCES +=	keyboard_x.c \
 			../hostfs-unix.c \
 			../rpc-linux.c
+  }
+}
+
+macx {
+  SOURCES +=		../network.c \
+			network_dialog.cpp \
+			keyboard_macosx.c \
+			../hostfs-macosx.c \
+			../rpc-macosx.c \
+			../macosx/hid-macosx.m \
+			../macosx/events-macosx.m \
+			../macosx/preferences-macosx.m \
+			../macosx/network-macosx.c \
+			../macosx/system-macosx.m \
+			choose_dialog.cpp
+
+  HEADERS +=		../network.h \
+			network_dialog.h \
+			keyboard_macosx.h \
+			../macosx/hid-macosx.h \
+			../macosx/events-macosx.h \
+			../macosx/preferences-macosx.h \
+			../macosx/system-macosx.h \
+			choose_dialog.h
+
+  ICON =		../macosx/rpcemu.icns
 }
 
 # Place exes in top level directory
@@ -206,4 +237,14 @@
 	TARGET = $$join(TARGET, , , -debug)
 }
 
-LIBS +=
+!macx {
+  LIBS +=
+}
+
+macx {
+	LIBS += -framework coreFoundation -framework IOKit -framework Foundation -framework Carbon
+
+	QMAKE_INFO_PLIST = ../macosx/Info.plist
+	QMAKE_BUNDLE = rpcemu
+	QMAKE_TARGET_BUNDLE_PREFIX = org.marutan.
+}
--- original/qt5/settings.cpp	2021-10-28 16:57:41.000000000 +0100
+++ src/qt5/settings.cpp	2021-11-01 19:29:13.000000000 +0000
@@ -106,7 +106,7 @@
 
 	snprintf(filename, sizeof(filename), "%srpc.cfg", rpcemu_get_datadir());
 
-	QSettings settings("rpc.cfg", QSettings::IniFormat);
+	QSettings settings(filename, QSettings::IniFormat);
 
 	/* Copy the contents of the configfile to the log */
 	QStringList keys = settings.childKeys();
@@ -265,7 +265,7 @@
 
 	snprintf(filename, sizeof(filename), "%srpc.cfg", rpcemu_get_datadir());
 
-	QSettings settings("rpc.cfg", QSettings::IniFormat);
+	QSettings settings(filename, QSettings::IniFormat);
 	settings.clear();
 
 	char s[256];
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/macosx/system-macosx.h	2021-10-31 11:59:49.000000000 +0000
@@ -0,0 +1,34 @@
+/*
+RPCEmu - An Acorn system emulator
+
+Copyright (C) 2017 Peter Howkins
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef __SYSTEM_MACOSX_H__
+#define __SYSTEM_MACOSX_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern unsigned int get_macosx_version(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
--- /dev/null	2021-11-02 20:38:02.000000000 +0000
+++ src/macosx/system-macosx.m	2021-10-31 11:59:49.000000000 +0000
@@ -0,0 +1,35 @@
+/*
+RPCEmu - An Acorn system emulator
+
+Copyright (C) 2017 Matthew Howkins
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <stddef.h>
+#include <stdint.h>
+
+#include <Cocoa/Cocoa.h>
+#include <Carbon/Carbon.h>
+
+unsigned int get_macosx_version(void)
+{
+    NSOperatingSystemVersion version;
+    
+    version = [[NSProcessInfo processInfo] operatingSystemVersion];
+    
+    return (version.majorVersion << 16) | (version.minorVersion << 8) | (version.patchVersion);
+}
+
